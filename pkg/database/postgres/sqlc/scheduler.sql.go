// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scheduler.sql

package sqlc

import (
	"context"
)

const getExecutionAggregations = `-- name: GetExecutionAggregations :many
SELECT execution_id, global, step, created_at, updated_at
FROM test_workflow_resource_aggregations r
WHERE
    r.execution_id = $1
`

func (q *Queries) GetExecutionAggregations(ctx context.Context, executionID string) ([]TestWorkflowResourceAggregation, error) {
	rows, err := q.db.Query(ctx, getExecutionAggregations, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowResourceAggregation
	for rows.Next() {
		var i TestWorkflowResourceAggregation
		if err := rows.Scan(
			&i.ExecutionID,
			&i.Global,
			&i.Step,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionOutputs = `-- name: GetExecutionOutputs :many
SELECT id, execution_id, ref, name, value, created_at
FROM test_workflow_outputs o
WHERE
    o.execution_id = $1
`

func (q *Queries) GetExecutionOutputs(ctx context.Context, executionID string) ([]TestWorkflowOutput, error) {
	rows, err := q.db.Query(ctx, getExecutionOutputs, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowOutput
	for rows.Next() {
		var i TestWorkflowOutput
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionReports = `-- name: GetExecutionReports :many
SELECT id, execution_id, ref, kind, file, summary, created_at
FROM test_workflow_reports r
WHERE
    r.execution_id = $1
`

func (q *Queries) GetExecutionReports(ctx context.Context, executionID string) ([]TestWorkflowReport, error) {
	rows, err := q.db.Query(ctx, getExecutionReports, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowReport
	for rows.Next() {
		var i TestWorkflowReport
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Kind,
			&i.File,
			&i.Summary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionSignatures = `-- name: GetExecutionSignatures :many
SELECT id, execution_id, ref, name, category, optional, negative, parent_id, created_at
FROM test_workflow_signatures s
WHERE
    s.execution_id = $1
`

func (q *Queries) GetExecutionSignatures(ctx context.Context, executionID string) ([]TestWorkflowSignature, error) {
	rows, err := q.db.Query(ctx, getExecutionSignatures, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowSignature
	for rows.Next() {
		var i TestWorkflowSignature
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Name,
			&i.Category,
			&i.Optional,
			&i.Negative,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextExecution = `-- name: GetNextExecution :one
SELECT
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at, e.organization_id, e.environment_id, e.runtime,
    r.execution_id, r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at, r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms, r.pauses, r.initialization, r.steps, r.created_at, r.updated_at
FROM
    test_workflow_executions e
        JOIN test_workflow_results r ON e.id = r.execution_id
WHERE
    r.status IS NULL
   OR r.status IN ('queued', 'assigned', 'starting')
ORDER BY
    e.scheduled_at
LIMIT
    1
`

type GetNextExecutionRow struct {
	TestWorkflowExecution TestWorkflowExecution `db:"test_workflow_execution" json:"test_workflow_execution"`
	TestWorkflowResult    TestWorkflowResult    `db:"test_workflow_result" json:"test_workflow_result"`
}

func (q *Queries) GetNextExecution(ctx context.Context) (GetNextExecutionRow, error) {
	row := q.db.QueryRow(ctx, getNextExecution)
	var i GetNextExecutionRow
	err := row.Scan(
		&i.TestWorkflowExecution.ID,
		&i.TestWorkflowExecution.GroupID,
		&i.TestWorkflowExecution.RunnerID,
		&i.TestWorkflowExecution.RunnerTarget,
		&i.TestWorkflowExecution.RunnerOriginalTarget,
		&i.TestWorkflowExecution.Name,
		&i.TestWorkflowExecution.Namespace,
		&i.TestWorkflowExecution.Number,
		&i.TestWorkflowExecution.ScheduledAt,
		&i.TestWorkflowExecution.AssignedAt,
		&i.TestWorkflowExecution.StatusAt,
		&i.TestWorkflowExecution.TestWorkflowExecutionName,
		&i.TestWorkflowExecution.DisableWebhooks,
		&i.TestWorkflowExecution.Tags,
		&i.TestWorkflowExecution.RunningContext,
		&i.TestWorkflowExecution.ConfigParams,
		&i.TestWorkflowExecution.CreatedAt,
		&i.TestWorkflowExecution.UpdatedAt,
		&i.TestWorkflowExecution.OrganizationID,
		&i.TestWorkflowExecution.EnvironmentID,
		&i.TestWorkflowExecution.Runtime,
		&i.TestWorkflowResult.ExecutionID,
		&i.TestWorkflowResult.Status,
		&i.TestWorkflowResult.PredictedStatus,
		&i.TestWorkflowResult.QueuedAt,
		&i.TestWorkflowResult.StartedAt,
		&i.TestWorkflowResult.FinishedAt,
		&i.TestWorkflowResult.Duration,
		&i.TestWorkflowResult.TotalDuration,
		&i.TestWorkflowResult.DurationMs,
		&i.TestWorkflowResult.PausedMs,
		&i.TestWorkflowResult.TotalDurationMs,
		&i.TestWorkflowResult.Pauses,
		&i.TestWorkflowResult.Initialization,
		&i.TestWorkflowResult.Steps,
		&i.TestWorkflowResult.CreatedAt,
		&i.TestWorkflowResult.UpdatedAt,
	)
	return i, err
}
