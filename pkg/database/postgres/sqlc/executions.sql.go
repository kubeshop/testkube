// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: executions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const abortTestWorkflowExecutionIfQueued = `-- name: AbortTestWorkflowExecutionIfQueued :one
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
    AND test_workflow_executions.id = r.execution_id
    AND r.status IN ('queued', 'running', 'paused')
    AND (test_workflow_executions.runner_id IS NULL OR test_workflow_executions.runner_id = '')
RETURNING test_workflow_executions.id
`

type AbortTestWorkflowExecutionIfQueuedParams struct {
	AbortTime pgtype.Timestamptz `db:"abort_time" json:"abort_time"`
	ID        string             `db:"id" json:"id"`
}

func (q *Queries) AbortTestWorkflowExecutionIfQueued(ctx context.Context, arg AbortTestWorkflowExecutionIfQueuedParams) (string, error) {
	row := q.db.QueryRow(ctx, abortTestWorkflowExecutionIfQueued, arg.AbortTime, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const abortTestWorkflowResultIfQueued = `-- name: AbortTestWorkflowResultIfQueued :exec
UPDATE test_workflow_results 
SET 
    status = 'aborted',
    predicted_status = 'aborted',
    finished_at = $1,
    initialization = jsonb_set(
        jsonb_set(
            jsonb_set(COALESCE(initialization, '{}'::jsonb), '{status}', '"aborted"'),
            '{errormessage}', '"Aborted before initialization."'
        ),
        '{finishedat}', to_jsonb($1::timestamp)
    )
WHERE execution_id = $2
    AND status IN ('queued', 'running', 'paused')
`

type AbortTestWorkflowResultIfQueuedParams struct {
	AbortTime pgtype.Timestamptz `db:"abort_time" json:"abort_time"`
	ID        string             `db:"id" json:"id"`
}

func (q *Queries) AbortTestWorkflowResultIfQueued(ctx context.Context, arg AbortTestWorkflowResultIfQueuedParams) error {
	_, err := q.db.Exec(ctx, abortTestWorkflowResultIfQueued, arg.AbortTime, arg.ID)
	return err
}

const assignTestWorkflowExecution = `-- name: AssignTestWorkflowExecution :one
UPDATE test_workflow_executions 
SET 
    runner_id = $1,
    assigned_at = $2
FROM test_workflow_results r
WHERE test_workflow_executions.id = $3
    AND test_workflow_executions.id = r.execution_id
    AND r.status = 'queued'
    AND ((test_workflow_executions.runner_id IS NULL OR test_workflow_executions.runner_id = '')
         OR (test_workflow_executions.runner_id = $1 AND assigned_at < $2)
         OR (test_workflow_executions.runner_id = $4 AND assigned_at < NOW() - INTERVAL '1 minute' AND assigned_at < $2))
RETURNING test_workflow_executions.id
`

type AssignTestWorkflowExecutionParams struct {
	NewRunnerID  pgtype.Text        `db:"new_runner_id" json:"new_runner_id"`
	AssignedAt   pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	ID           string             `db:"id" json:"id"`
	PrevRunnerID pgtype.Text        `db:"prev_runner_id" json:"prev_runner_id"`
}

func (q *Queries) AssignTestWorkflowExecution(ctx context.Context, arg AssignTestWorkflowExecutionParams) (string, error) {
	row := q.db.QueryRow(ctx, assignTestWorkflowExecution,
		arg.NewRunnerID,
		arg.AssignedAt,
		arg.ID,
		arg.PrevRunnerID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllTestWorkflowExecutions = `-- name: DeleteAllTestWorkflowExecutions :exec
DELETE FROM test_workflow_executions
`

func (q *Queries) DeleteAllTestWorkflowExecutions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllTestWorkflowExecutions)
	return err
}

const deleteTestWorkflow = `-- name: DeleteTestWorkflow :exec
DELETE FROM test_workflows WHERE execution_id = $1 AND workflow_type = $2
`

type DeleteTestWorkflowParams struct {
	ExecutionID  string `db:"execution_id" json:"execution_id"`
	WorkflowType string `db:"workflow_type" json:"workflow_type"`
}

func (q *Queries) DeleteTestWorkflow(ctx context.Context, arg DeleteTestWorkflowParams) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflow, arg.ExecutionID, arg.WorkflowType)
	return err
}

const deleteTestWorkflowExecutionsByTestWorkflow = `-- name: DeleteTestWorkflowExecutionsByTestWorkflow :exec
DELETE FROM test_workflow_executions e
USING test_workflows w
WHERE e.id = w.execution_id 
  AND w.workflow_type = 'workflow' 
  AND w.name = $1
`

func (q *Queries) DeleteTestWorkflowExecutionsByTestWorkflow(ctx context.Context, workflowName string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowExecutionsByTestWorkflow, workflowName)
	return err
}

const deleteTestWorkflowExecutionsByTestWorkflows = `-- name: DeleteTestWorkflowExecutionsByTestWorkflows :exec
DELETE FROM test_workflow_executions e
USING test_workflows w
WHERE e.id = w.execution_id 
  AND w.workflow_type = 'workflow' 
  AND w.name = ANY($1)
`

func (q *Queries) DeleteTestWorkflowExecutionsByTestWorkflows(ctx context.Context, workflowNames []string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowExecutionsByTestWorkflows, workflowNames)
	return err
}

const deleteTestWorkflowOutputs = `-- name: DeleteTestWorkflowOutputs :exec
DELETE FROM test_workflow_outputs WHERE execution_id = $1
`

func (q *Queries) DeleteTestWorkflowOutputs(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowOutputs, executionID)
	return err
}

const deleteTestWorkflowReports = `-- name: DeleteTestWorkflowReports :exec
DELETE FROM test_workflow_reports WHERE execution_id = $1
`

func (q *Queries) DeleteTestWorkflowReports(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowReports, executionID)
	return err
}

const deleteTestWorkflowResourceAggregations = `-- name: DeleteTestWorkflowResourceAggregations :exec
DELETE FROM test_workflow_resource_aggregations WHERE execution_id = $1
`

func (q *Queries) DeleteTestWorkflowResourceAggregations(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowResourceAggregations, executionID)
	return err
}

const deleteTestWorkflowResult = `-- name: DeleteTestWorkflowResult :exec
DELETE FROM test_workflow_results WHERE execution_id = $1
`

func (q *Queries) DeleteTestWorkflowResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowResult, executionID)
	return err
}

const deleteTestWorkflowSignatures = `-- name: DeleteTestWorkflowSignatures :exec
DELETE FROM test_workflow_signatures WHERE execution_id = $1
`

func (q *Queries) DeleteTestWorkflowSignatures(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowSignatures, executionID)
	return err
}

const getFinishedTestWorkflowExecutions = `-- name: GetFinishedTestWorkflowExecutions :many
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step    
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE r.status IN ('passed', 'failed', 'aborted')
    AND (COALESCE($1::text, '') = '' OR w.name = $1::text)
    AND (COALESCE($2::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR w.name = ANY($2::text[]))
    AND (COALESCE($3::text, '') = '' OR e.name ILIKE '%' || $3::text || '%')
    AND (COALESCE($4::timestamptz, '1900-01-01'::timestamptz) = '1900-01-01'::timestamptz OR e.scheduled_at >= $4::timestamptz)
    AND (COALESCE($5::timestamptz, '2100-01-01'::timestamptz) = '2100-01-01'::timestamptz OR e.scheduled_at <= $5::timestamptz)
    AND (COALESCE($6::integer, 0) = 0 OR e.scheduled_at >= NOW() - (COALESCE($6::integer, 0) || ' days')::interval)
    AND (COALESCE($7::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR r.status = ANY($7::text[]))
    AND (COALESCE($8::text, '') = '' OR e.runner_id = $8::text)
    AND (COALESCE($9::boolean, NULL) IS NULL OR 
         ($9::boolean = true AND e.runner_id IS NOT NULL AND e.runner_id != '') OR 
         ($9::boolean = false AND (e.runner_id IS NULL OR e.runner_id = '')))
    AND (COALESCE($10::text, '') = '' OR e.running_context->'actor'->>'name' = $10::text)
    AND (COALESCE($11::text, '') = '' OR e.running_context->'actor'->>'type_' = $11::text)
    AND (COALESCE($12::text, '') = '' OR e.id = $12::text OR e.group_id = $12::text)
    AND (COALESCE($13::boolean, NULL) IS NULL OR 
         ($13::boolean = true AND (r.status != 'queued' OR r.steps IS NOT NULL)) OR
         ($13::boolean = false AND r.status = 'queued' AND (r.steps IS NULL OR r.steps = '{}'::jsonb)))
    AND (     
        (COALESCE($14::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($14::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (e.tags ? (key_condition->>'key'))
                    ELSE
                        e.tags ? (key_condition->>'key')
                END
            ) = jsonb_array_length($14::jsonb)
        )
        AND
        (COALESCE($15::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($15::jsonb) AS condition
                WHERE e.tags->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($16::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($16::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) > 0
        )
        OR
        (COALESCE($17::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($17::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($18::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($18::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) = jsonb_array_length($18::jsonb)
        )
        AND
        (COALESCE($19::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($19::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) = jsonb_array_length($19::jsonb)
        )
    )
ORDER BY e.scheduled_at DESC
LIMIT $21 OFFSET $20
`

type GetFinishedTestWorkflowExecutionsParams GetTestWorkflowExecutionsParams

type GetFinishedTestWorkflowExecutionsRow GetTestWorkflowExecutionRow

func (q *Queries) GetFinishedTestWorkflowExecutions(ctx context.Context, arg GetFinishedTestWorkflowExecutionsParams) ([]GetFinishedTestWorkflowExecutionsRow, error) {
	rows, err := q.db.Query(ctx, getFinishedTestWorkflowExecutions,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.TagKeys,
		arg.TagConditions,
		arg.LabelKeys,
		arg.LabelConditions,
		arg.SelectorKeys,
		arg.SelectorConditions,
		arg.Fst,
		arg.Lmt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFinishedTestWorkflowExecutionsRow
	for rows.Next() {
		var i GetFinishedTestWorkflowExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestTestWorkflowExecutionByTestWorkflow = `-- name: GetLatestTestWorkflowExecutionByTestWorkflow :one
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE w.name = $1 
ORDER BY e.status_at DESC 
LIMIT 1
`

type GetLatestTestWorkflowExecutionByTestWorkflowRow GetTestWorkflowExecutionRow

func (q *Queries) GetLatestTestWorkflowExecutionByTestWorkflow(ctx context.Context, workflowName string) (GetLatestTestWorkflowExecutionByTestWorkflowRow, error) {
	row := q.db.QueryRow(ctx, getLatestTestWorkflowExecutionByTestWorkflow, workflowName)
	var i GetLatestTestWorkflowExecutionByTestWorkflowRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.PredictedStatus,
		&i.QueuedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Duration,
		&i.TotalDuration,
		&i.DurationMs,
		&i.PausedMs,
		&i.TotalDurationMs,
		&i.Pauses,
		&i.Initialization,
		&i.Steps,
		&i.WorkflowName,
		&i.WorkflowNamespace,
		&i.WorkflowDescription,
		&i.WorkflowLabels,
		&i.WorkflowAnnotations,
		&i.WorkflowCreated,
		&i.WorkflowUpdated,
		&i.WorkflowSpec,
		&i.WorkflowReadOnly,
		&i.WorkflowStatus,
		&i.WorkflowHealth,
		&i.ResolvedWorkflowName,
		&i.ResolvedWorkflowNamespace,
		&i.ResolvedWorkflowDescription,
		&i.ResolvedWorkflowLabels,
		&i.ResolvedWorkflowAnnotations,
		&i.ResolvedWorkflowCreated,
		&i.ResolvedWorkflowUpdated,
		&i.ResolvedWorkflowSpec,
		&i.ResolvedWorkflowReadOnly,
		&i.ResolvedWorkflowStatus,
		&i.SignaturesJson,
		&i.OutputsJson,
		&i.ReportsJson,
		&i.ResourceAggregationsGlobal,
		&i.ResourceAggregationsStep,
	)
	return i, err
}

const getLatestTestWorkflowExecutionsByTestWorkflows = `-- name: GetLatestTestWorkflowExecutionsByTestWorkflows :many
SELECT DISTINCT ON (w.name)
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE w.name = ANY($1)
ORDER BY w.name, e.status_at DESC
`

type GetLatestTestWorkflowExecutionsByTestWorkflowsRow GetTestWorkflowExecutionRow

func (q *Queries) GetLatestTestWorkflowExecutionsByTestWorkflows(ctx context.Context, workflowNames []string) ([]GetLatestTestWorkflowExecutionsByTestWorkflowsRow, error) {
	rows, err := q.db.Query(ctx, getLatestTestWorkflowExecutionsByTestWorkflows, workflowNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestTestWorkflowExecutionsByTestWorkflowsRow
	for rows.Next() {
		var i GetLatestTestWorkflowExecutionsByTestWorkflowsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousFinishedState = `-- name: GetPreviousFinishedState :one
SELECT r.status
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
WHERE w.name = $1
    AND r.finished_at < $2
    AND r.status IN ('passed', 'failed', 'skipped', 'aborted', 'canceled', 'timeout')
ORDER BY r.finished_at DESC
LIMIT 1
`

type GetPreviousFinishedStateParams struct {
	WorkflowName pgtype.Text        `db:"workflow_name" json:"workflow_name"`
	Date         pgtype.Timestamptz `db:"date" json:"date"`
}

func (q *Queries) GetPreviousFinishedState(ctx context.Context, arg GetPreviousFinishedStateParams) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getPreviousFinishedState, arg.WorkflowName, arg.Date)
	var status pgtype.Text
	err := row.Scan(&status)
	return status, err
}

const getRunningTestWorkflowExecutions = `-- name: GetRunningTestWorkflowExecutions :many
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE r.status IN ('paused', 'running', 'queued')
ORDER BY e.id DESC
`

type GetRunningTestWorkflowExecutionsRow GetTestWorkflowExecutionRow

func (q *Queries) GetRunningTestWorkflowExecutions(ctx context.Context) ([]GetRunningTestWorkflowExecutionsRow, error) {
	rows, err := q.db.Query(ctx, getRunningTestWorkflowExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRunningTestWorkflowExecutionsRow
	for rows.Next() {
		var i GetRunningTestWorkflowExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecution = `-- name: GetTestWorkflowExecution :one
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE e.id = $1 OR e.name = $1
`

type GetTestWorkflowExecutionRow struct {
	ID                          string             `db:"id" json:"id"`
	GroupID                     pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID                    pgtype.Text        `db:"runner_id" json:"runner_id"`
	RunnerTarget                []byte             `db:"runner_target" json:"runner_target"`
	RunnerOriginalTarget        []byte             `db:"runner_original_target" json:"runner_original_target"`
	Name                        string             `db:"name" json:"name"`
	Namespace                   pgtype.Text        `db:"namespace" json:"namespace"`
	Number                      pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt                 pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	AssignedAt                  pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	StatusAt                    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	TestWorkflowExecutionName   pgtype.Text        `db:"test_workflow_execution_name" json:"test_workflow_execution_name"`
	DisableWebhooks             pgtype.Bool        `db:"disable_webhooks" json:"disable_webhooks"`
	Tags                        []byte             `db:"tags" json:"tags"`
	RunningContext              []byte             `db:"running_context" json:"running_context"`
	ConfigParams                []byte             `db:"config_params" json:"config_params"`
	CreatedAt                   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Status                      pgtype.Text        `db:"status" json:"status"`
	PredictedStatus             pgtype.Text        `db:"predicted_status" json:"predicted_status"`
	QueuedAt                    pgtype.Timestamptz `db:"queued_at" json:"queued_at"`
	StartedAt                   pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt                  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	Duration                    pgtype.Text        `db:"duration" json:"duration"`
	TotalDuration               pgtype.Text        `db:"total_duration" json:"total_duration"`
	DurationMs                  pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	PausedMs                    pgtype.Int4        `db:"paused_ms" json:"paused_ms"`
	TotalDurationMs             pgtype.Int4        `db:"total_duration_ms" json:"total_duration_ms"`
	Pauses                      []byte             `db:"pauses" json:"pauses"`
	Initialization              []byte             `db:"initialization" json:"initialization"`
	Steps                       []byte             `db:"steps" json:"steps"`
	WorkflowName                pgtype.Text        `db:"workflow_name" json:"workflow_name"`
	WorkflowNamespace           pgtype.Text        `db:"workflow_namespace" json:"workflow_namespace"`
	WorkflowDescription         pgtype.Text        `db:"workflow_description" json:"workflow_description"`
	WorkflowLabels              []byte             `db:"workflow_labels" json:"workflow_labels"`
	WorkflowAnnotations         []byte             `db:"workflow_annotations" json:"workflow_annotations"`
	WorkflowCreated             pgtype.Timestamptz `db:"workflow_created" json:"workflow_created"`
	WorkflowUpdated             pgtype.Timestamptz `db:"workflow_updated" json:"workflow_updated"`
	WorkflowSpec                []byte             `db:"workflow_spec" json:"workflow_spec"`
	WorkflowReadOnly            pgtype.Bool        `db:"workflow_read_only" json:"workflow_read_only"`
	WorkflowStatus              []byte             `db:"workflow_status" json:"workflow_status"`
	WorkflowHealth              []byte             `db:"workflow_health" json:"workflow_health"`
	ResolvedWorkflowName        pgtype.Text        `db:"resolved_workflow_name" json:"resolved_workflow_name"`
	ResolvedWorkflowNamespace   pgtype.Text        `db:"resolved_workflow_namespace" json:"resolved_workflow_namespace"`
	ResolvedWorkflowDescription pgtype.Text        `db:"resolved_workflow_description" json:"resolved_workflow_description"`
	ResolvedWorkflowLabels      []byte             `db:"resolved_workflow_labels" json:"resolved_workflow_labels"`
	ResolvedWorkflowAnnotations []byte             `db:"resolved_workflow_annotations" json:"resolved_workflow_annotations"`
	ResolvedWorkflowCreated     pgtype.Timestamptz `db:"resolved_workflow_created" json:"resolved_workflow_created"`
	ResolvedWorkflowUpdated     pgtype.Timestamptz `db:"resolved_workflow_updated" json:"resolved_workflow_updated"`
	ResolvedWorkflowSpec        []byte             `db:"resolved_workflow_spec" json:"resolved_workflow_spec"`
	ResolvedWorkflowReadOnly    pgtype.Bool        `db:"resolved_workflow_read_only" json:"resolved_workflow_read_only"`
	ResolvedWorkflowStatus      []byte             `db:"resolved_workflow_status" json:"resolved_workflow_status"`
	SignaturesJson              []byte             `db:"signatures_json" json:"signatures_json"`
	OutputsJson                 []byte             `db:"outputs_json" json:"outputs_json"`
	ReportsJson                 []byte             `db:"reports_json" json:"reports_json"`
	ResourceAggregationsGlobal  []byte             `db:"resource_aggregations_global" json:"resource_aggregations_global"`
	ResourceAggregationsStep    []byte             `db:"resource_aggregations_step" json:"resource_aggregations_step"`
}

func (q *Queries) GetTestWorkflowExecution(ctx context.Context, id string) (GetTestWorkflowExecutionRow, error) {
	row := q.db.QueryRow(ctx, getTestWorkflowExecution, id)
	var i GetTestWorkflowExecutionRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.PredictedStatus,
		&i.QueuedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Duration,
		&i.TotalDuration,
		&i.DurationMs,
		&i.PausedMs,
		&i.TotalDurationMs,
		&i.Pauses,
		&i.Initialization,
		&i.Steps,
		&i.WorkflowName,
		&i.WorkflowNamespace,
		&i.WorkflowDescription,
		&i.WorkflowLabels,
		&i.WorkflowAnnotations,
		&i.WorkflowCreated,
		&i.WorkflowUpdated,
		&i.WorkflowSpec,
		&i.WorkflowReadOnly,
		&i.WorkflowStatus,
		&i.WorkflowHealth,
		&i.ResolvedWorkflowName,
		&i.ResolvedWorkflowNamespace,
		&i.ResolvedWorkflowDescription,
		&i.ResolvedWorkflowLabels,
		&i.ResolvedWorkflowAnnotations,
		&i.ResolvedWorkflowCreated,
		&i.ResolvedWorkflowUpdated,
		&i.ResolvedWorkflowSpec,
		&i.ResolvedWorkflowReadOnly,
		&i.ResolvedWorkflowStatus,
		&i.SignaturesJson,
		&i.OutputsJson,
		&i.ReportsJson,
		&i.ResourceAggregationsGlobal,
		&i.ResourceAggregationsStep,
	)
	return i, err
}

const getTestWorkflowExecutionByNameAndTestWorkflow = `-- name: GetTestWorkflowExecutionByNameAndTestWorkflow :one
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE (e.id = $1 OR e.name = $1) AND w.name = $2
`

type GetTestWorkflowExecutionByNameAndTestWorkflowParams struct {
	Name         string      `db:"name" json:"name"`
	WorkflowName pgtype.Text `db:"workflow_name" json:"workflow_name"`
}

type GetTestWorkflowExecutionByNameAndTestWorkflowRow GetTestWorkflowExecutionRow

func (q *Queries) GetTestWorkflowExecutionByNameAndTestWorkflow(ctx context.Context, arg GetTestWorkflowExecutionByNameAndTestWorkflowParams) (GetTestWorkflowExecutionByNameAndTestWorkflowRow, error) {
	row := q.db.QueryRow(ctx, getTestWorkflowExecutionByNameAndTestWorkflow, arg.Name, arg.WorkflowName)
	var i GetTestWorkflowExecutionByNameAndTestWorkflowRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.PredictedStatus,
		&i.QueuedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Duration,
		&i.TotalDuration,
		&i.DurationMs,
		&i.PausedMs,
		&i.TotalDurationMs,
		&i.Pauses,
		&i.Initialization,
		&i.Steps,
		&i.WorkflowName,
		&i.WorkflowNamespace,
		&i.WorkflowDescription,
		&i.WorkflowLabels,
		&i.WorkflowAnnotations,
		&i.WorkflowCreated,
		&i.WorkflowUpdated,
		&i.WorkflowSpec,
		&i.WorkflowReadOnly,
		&i.WorkflowStatus,
		&i.WorkflowHealth,
		&i.ResolvedWorkflowName,
		&i.ResolvedWorkflowNamespace,
		&i.ResolvedWorkflowDescription,
		&i.ResolvedWorkflowLabels,
		&i.ResolvedWorkflowAnnotations,
		&i.ResolvedWorkflowCreated,
		&i.ResolvedWorkflowUpdated,
		&i.ResolvedWorkflowSpec,
		&i.ResolvedWorkflowReadOnly,
		&i.ResolvedWorkflowStatus,
		&i.SignaturesJson,
		&i.OutputsJson,
		&i.ReportsJson,
		&i.ResourceAggregationsGlobal,
		&i.ResourceAggregationsStep,
	)
	return i, err
}

const getTestWorkflowExecutionTags = `-- name: GetTestWorkflowExecutionTags :many
WITH tag_extracts AS (
    SELECT 
        e.id,
        w.name as workflow_name,
        tag_pair.key as tag_key,
        tag_pair.value as tag_value
    FROM test_workflow_executions e
    LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
    CROSS JOIN LATERAL jsonb_each_text(e.tags) AS tag_pair(key, value)
    WHERE e.tags IS NOT NULL 
        AND e.tags != '{}'::jsonb
        AND jsonb_typeof(e.tags) = 'object'
)
SELECT 
    tag_key,
    array_agg(DISTINCT tag_value ORDER BY tag_value) as values
FROM tag_extracts
WHERE (COALESCE($1::text, '') = '' OR workflow_name = $1::text)
GROUP BY tag_key
ORDER BY tag_key
`

type GetTestWorkflowExecutionTagsRow struct {
	TagKey string   `db:"tag_key" json:"tag_key"`
	Values []string `db:"values" json:"values"`
}

func (q *Queries) GetTestWorkflowExecutionTags(ctx context.Context, workflowName string) ([]GetTestWorkflowExecutionTagsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionTags, workflowName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionTagsRow
	for rows.Next() {
		var i GetTestWorkflowExecutionTagsRow
		if err := rows.Scan(&i.TagKey, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutions = `-- name: GetTestWorkflowExecutions :many
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE 1=1
    AND (COALESCE($1::text, '') = '' OR w.name = $1::text)
    AND (COALESCE($2::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR w.name = ANY($2::text[]))
    AND (COALESCE($3::text, '') = '' OR e.name ILIKE '%' || $3::text || '%')
    AND (COALESCE($4::timestamptz, '1900-01-01'::timestamptz) = '1900-01-01'::timestamptz OR e.scheduled_at >= $4::timestamptz)
    AND (COALESCE($5::timestamptz, '2100-01-01'::timestamptz) = '2100-01-01'::timestamptz OR e.scheduled_at <= $5::timestamptz)
    AND (COALESCE($6::integer, 0) = 0 OR e.scheduled_at >= NOW() - (COALESCE($6::integer, 0) || ' days')::interval)
    AND (COALESCE($7::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR r.status = ANY($7::text[]))
    AND (COALESCE($8::text, '') = '' OR e.runner_id = $8::text)
    AND (COALESCE($9::boolean, NULL) IS NULL OR 
         ($9::boolean = true AND e.runner_id IS NOT NULL AND e.runner_id != '') OR 
         ($9::boolean = false AND (e.runner_id IS NULL OR e.runner_id = '')))
    AND (COALESCE($10::text, '') = '' OR e.running_context->'actor'->>'name' = $10::text)
    AND (COALESCE($11::text, '') = '' OR e.running_context->'actor'->>'type_' = $11::text)
    AND (COALESCE($12::text, '') = '' OR e.id = $12::text OR e.group_id = $12::text)
    AND (COALESCE($13::boolean, NULL) IS NULL OR 
         ($13::boolean = true AND (r.status != 'queued' OR r.steps IS NOT NULL)) OR
         ($13::boolean = false AND r.status = 'queued' AND (r.steps IS NULL OR r.steps = '{}'::jsonb)))
    AND (     
        (COALESCE($14::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($14::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (e.tags ? (key_condition->>'key'))
                    ELSE
                        e.tags ? (key_condition->>'key')
                END
            ) = jsonb_array_length($14::jsonb)
        )
        AND
        (COALESCE($15::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($15::jsonb) AS condition
                WHERE e.tags->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($16::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($16::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) > 0
        )
        OR
        (COALESCE($17::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($17::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($18::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($18::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) = jsonb_array_length($18::jsonb)
        )
        AND
        (COALESCE($19::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($19::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) = jsonb_array_length($19::jsonb)
        )
    )
ORDER BY e.scheduled_at DESC
LIMIT $21 OFFSET $20
`

type GetTestWorkflowExecutionsParams struct {
	WorkflowName       pgtype.Text        `db:"workflow_name" json:"workflow_name"`
	WorkflowNames      []pgtype.Text      `db:"workflow_names" json:"workflow_names"`
	TextSearch         pgtype.Text        `db:"text_search" json:"text_search"`
	StartDate          pgtype.Timestamptz `db:"start_date" json:"start_date"`
	EndDate            pgtype.Timestamptz `db:"end_date" json:"end_date"`
	LastNDays          pgtype.Int4        `db:"last_n_days" json:"last_n_days"`
	Statuses           []pgtype.Text      `db:"statuses" json:"statuses"`
	RunnerID           pgtype.Text        `db:"runner_id" json:"runner_id"`
	Assigned           pgtype.Bool        `db:"assigned" json:"assigned"`
	ActorName          pgtype.Text        `db:"actor_name" json:"actor_name"`
	ActorType          pgtype.Text        `db:"actor_type" json:"actor_type"`
	GroupID            pgtype.Text        `db:"group_id" json:"group_id"`
	Initialized        pgtype.Bool        `db:"initialized" json:"initialized"`
	TagKeys            []byte             `db:"tag_keys" json:"tag_keys"`
	TagConditions      []byte             `db:"tag_conditions" json:"tag_conditions"`
	LabelKeys          []byte             `db:"label_keys" json:"label_keys"`
	LabelConditions    []byte             `db:"label_conditions" json:"label_conditions"`
	SelectorKeys       []byte             `db:"selector_keys" json:"selector_keys"`
	SelectorConditions []byte             `db:"selector_conditions" json:"selector_conditions"`
	Fst                int32              `db:"fst" json:"fst"`
	Lmt                int32              `db:"lmt" json:"lmt"`
}

type GetTestWorkflowExecutionsRow GetTestWorkflowExecutionRow

func (q *Queries) GetTestWorkflowExecutions(ctx context.Context, arg GetTestWorkflowExecutionsParams) ([]GetTestWorkflowExecutionsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutions,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.TagKeys,
		arg.TagConditions,
		arg.LabelKeys,
		arg.LabelConditions,
		arg.SelectorKeys,
		arg.SelectorConditions,
		arg.Fst,
		arg.Lmt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionsRow
	for rows.Next() {
		var i GetTestWorkflowExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutionsSummary = `-- name: GetTestWorkflowExecutionsSummary :many
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step    
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE 1=1
    AND (COALESCE($1::text, '') = '' OR w.name = $1::text)
    AND (COALESCE($2::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR w.name = ANY($2::text[]))
    AND (COALESCE($3::text, '') = '' OR e.name ILIKE '%' || $3::text || '%')
    AND (COALESCE($4::timestamptz, '1900-01-01'::timestamptz) = '1900-01-01'::timestamptz OR e.scheduled_at >= $4::timestamptz)
    AND (COALESCE($5::timestamptz, '2100-01-01'::timestamptz) = '2100-01-01'::timestamptz OR e.scheduled_at <= $5::timestamptz)
    AND (COALESCE($6::integer, 0) = 0 OR e.scheduled_at >= NOW() - (COALESCE($6::integer, 0) || ' days')::interval)
    AND (COALESCE($7::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR r.status = ANY($7::text[]))
    AND (COALESCE($8::text, '') = '' OR e.runner_id = $8::text)
    AND (COALESCE($9::boolean, NULL) IS NULL OR 
         ($9::boolean = true AND e.runner_id IS NOT NULL AND e.runner_id != '') OR 
         ($9::boolean = false AND (e.runner_id IS NULL OR e.runner_id = '')))
    AND (COALESCE($10::text, '') = '' OR e.running_context->'actor'->>'name' = $10::text)
    AND (COALESCE($11::text, '') = '' OR e.running_context->'actor'->>'type_' = $11::text)
    AND (COALESCE($12::text, '') = '' OR e.id = $12::text OR e.group_id = $12::text)
    AND (COALESCE($13::boolean, NULL) IS NULL OR 
         ($13::boolean = true AND (r.status != 'queued' OR r.steps IS NOT NULL)) OR
         ($13::boolean = false AND r.status = 'queued' AND (r.steps IS NULL OR r.steps = '{}'::jsonb)))
    AND (     
        (COALESCE($14::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($14::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (e.tags ? (key_condition->>'key'))
                    ELSE
                        e.tags ? (key_condition->>'key')
                END
            ) = jsonb_array_length($14::jsonb)
        )
        AND
        (COALESCE($15::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($15::jsonb) AS condition
                WHERE e.tags->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($16::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($16::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) > 0
        )
        OR
        (COALESCE($17::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($17::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($18::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($18::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) = jsonb_array_length($18::jsonb)
        )
        AND
        (COALESCE($19::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($19::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) = jsonb_array_length($19::jsonb)
        )
    )
ORDER BY e.scheduled_at DESC
LIMIT $21 OFFSET $20
`

type GetTestWorkflowExecutionsSummaryParams GetTestWorkflowExecutionsParams

type GetTestWorkflowExecutionsSummaryRow GetTestWorkflowExecutionRow

func (q *Queries) GetTestWorkflowExecutionsSummary(ctx context.Context, arg GetTestWorkflowExecutionsSummaryParams) ([]GetTestWorkflowExecutionsSummaryRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionsSummary,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.TagKeys,
		arg.TagConditions,
		arg.LabelKeys,
		arg.LabelConditions,
		arg.SelectorKeys,
		arg.SelectorConditions,
		arg.Fst,
		arg.Lmt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionsSummaryRow
	for rows.Next() {
		var i GetTestWorkflowExecutionsSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutionsTotals = `-- name: GetTestWorkflowExecutionsTotals :many
SELECT 
    r.status,
    COUNT(*) as count
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
WHERE 1=1
    AND (COALESCE($1::text, '') = '' OR w.name = $1::text)
    AND (COALESCE($2::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR w.name = ANY($2::text[]))
    AND (COALESCE($3::text, '') = '' OR e.name ILIKE '%' || $3::text || '%')
    AND (COALESCE($4::timestamptz, '1900-01-01'::timestamptz) = '1900-01-01'::timestamptz OR e.scheduled_at >= $4::timestamptz)
    AND (COALESCE($5::timestamptz, '2100-01-01'::timestamptz) = '2100-01-01'::timestamptz OR e.scheduled_at <= $5::timestamptz)
    AND (COALESCE($6::integer, 0) = 0 OR e.scheduled_at >= NOW() - (COALESCE($6::integer, 0) || ' days')::interval)
    AND (COALESCE($7::text[], ARRAY[]::text[]) = ARRAY[]::text[] OR r.status = ANY($7::text[]))
    AND (COALESCE($8::text, '') = '' OR e.runner_id = $8::text)
    AND (COALESCE($9::boolean, NULL) IS NULL OR 
         ($9::boolean = true AND e.runner_id IS NOT NULL AND e.runner_id != '') OR 
         ($9::boolean = false AND (e.runner_id IS NULL OR e.runner_id = '')))
    AND (COALESCE($10::text, '') = '' OR e.running_context->'actor'->>'name' = $10::text)
    AND (COALESCE($11::text, '') = '' OR e.running_context->'actor'->>'type_' = $11::text)
    AND (COALESCE($12::text, '') = '' OR e.id = $12::text OR e.group_id = $12::text)
    AND (COALESCE($13::boolean, NULL) IS NULL OR 
         ($13::boolean = true AND (r.status != 'queued' OR r.steps IS NOT NULL)) OR
         ($13::boolean = false AND r.status = 'queued' AND (r.steps IS NULL OR r.steps = '{}'::jsonb)))
    AND (     
        (COALESCE($14::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($14::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (e.tags ? (key_condition->>'key'))
                    ELSE
                        e.tags ? (key_condition->>'key')
                END
            ) = jsonb_array_length($14::jsonb)
        )
        AND
        (COALESCE($15::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($15::jsonb) AS condition
                WHERE e.tags->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($16::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($16::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) > 0
        )
        OR
        (COALESCE($17::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($17::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) > 0
        )
    )
    AND (
        (COALESCE($18::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($18::jsonb) AS key_condition
                WHERE 
                CASE 
                    WHEN key_condition->>'operator' = 'not_exists' THEN
                        NOT (w.labels ? (key_condition->>'key'))
                    ELSE
                        w.labels ? (key_condition->>'key')
                END
            ) = jsonb_array_length($18::jsonb)
        )
        AND
        (COALESCE($19::jsonb, '[]'::jsonb) = '[]'::jsonb OR 
            (SELECT COUNT(*) FROM jsonb_array_elements($19::jsonb) AS condition
                WHERE w.labels->>(condition->>'key') = ANY(
                    SELECT jsonb_array_elements_text(condition->'values')
                )
            ) = jsonb_array_length($19::jsonb)
        )
    )
GROUP BY r.status
`

type GetTestWorkflowExecutionsTotalsParams GetTestWorkflowExecutionsParams

type GetTestWorkflowExecutionsTotalsRow struct {
	Status pgtype.Text `db:"status" json:"status"`
	Count  int64       `db:"count" json:"count"`
}

func (q *Queries) GetTestWorkflowExecutionsTotals(ctx context.Context, arg GetTestWorkflowExecutionsTotalsParams) ([]GetTestWorkflowExecutionsTotalsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionsTotals,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.TagKeys,
		arg.TagConditions,
		arg.LabelKeys,
		arg.LabelConditions,
		arg.SelectorKeys,
		arg.SelectorConditions,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionsTotalsRow
	for rows.Next() {
		var i GetTestWorkflowExecutionsTotalsRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowMetrics = `-- name: GetTestWorkflowMetrics :many
SELECT 
    e.id as execution_id,
    e.group_id,
    r.duration,
    r.duration_ms,
    r.status,
    e.name,
    e.scheduled_at as start_time,
    e.runner_id
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
WHERE w.name = $1
    AND ($2 = 0 OR e.scheduled_at >= NOW() - ($2 || ' days')::interval)
ORDER BY e.scheduled_at DESC
LIMIT $3
`

type GetTestWorkflowMetricsParams struct {
	WorkflowName pgtype.Text `db:"workflow_name" json:"workflow_name"`
	LastNDays    pgtype.Int4 `db:"last_n_days" json:"last_n_days"`
	Lmt          int32       `db:"lmt" json:"lmt"`
}

type GetTestWorkflowMetricsRow struct {
	ExecutionID string             `db:"execution_id" json:"execution_id"`
	GroupID     pgtype.Text        `db:"group_id" json:"group_id"`
	Duration    pgtype.Text        `db:"duration" json:"duration"`
	DurationMs  pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	Status      pgtype.Text        `db:"status" json:"status"`
	Name        string             `db:"name" json:"name"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	RunnerID    pgtype.Text        `db:"runner_id" json:"runner_id"`
}

func (q *Queries) GetTestWorkflowMetrics(ctx context.Context, arg GetTestWorkflowMetricsParams) ([]GetTestWorkflowMetricsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowMetrics, arg.WorkflowName, arg.LastNDays, arg.Lmt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowMetricsRow
	for rows.Next() {
		var i GetTestWorkflowMetricsRow
		if err := rows.Scan(
			&i.ExecutionID,
			&i.GroupID,
			&i.Duration,
			&i.DurationMs,
			&i.Status,
			&i.Name,
			&i.StartTime,
			&i.RunnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnassignedTestWorkflowExecutions = `-- name: GetUnassignedTestWorkflowExecutions :many
SELECT 
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at,
    r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at,
    r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms,
    r.pauses, r.initialization, r.steps,
    w.name as workflow_name, w.namespace as workflow_namespace, w.description as workflow_description,
    w.labels as workflow_labels, w.annotations as workflow_annotations, w.created as workflow_created,
    w.updated as workflow_updated, w.spec as workflow_spec, w.read_only as workflow_read_only,
    w.status as workflow_status, w.health as workflow_health,
    rw.name as resolved_workflow_name, rw.namespace as resolved_workflow_namespace, 
    rw.description as resolved_workflow_description, rw.labels as resolved_workflow_labels,
    rw.annotations as resolved_workflow_annotations, rw.created as resolved_workflow_created,
    rw.updated as resolved_workflow_updated, rw.spec as resolved_workflow_spec,
    rw.read_only as resolved_workflow_read_only, rw.status as resolved_workflow_status,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', s.id,
                'ref', s.ref,
                'name', s.name,
                'category', s.category,
                'optional', s.optional,
                'negative', s.negative,
                'parent_id', s.parent_id
            ) ORDER BY s.id
        ) FROM test_workflow_signatures s WHERE s.execution_id = e.id),
        '[]'::json
    ) as signatures_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', o.id,
                'ref', o.ref,
                'name', o.name,
                'value', o.value
            ) ORDER BY o.id
        ) FROM test_workflow_outputs o WHERE o.execution_id = e.id),
        '[]'::json
    ) as outputs_json,
    COALESCE(
        (SELECT json_agg(
            json_build_object(
                'id', rep.id,
                'ref', rep.ref,
                'kind', rep.kind,
                'file', rep.file,
                'summary', rep.summary
            ) ORDER BY rep.id
        ) FROM test_workflow_reports rep WHERE rep.execution_id = e.id),
        '[]'::json
    ) as reports_json,
    ra.global as resource_aggregations_global,
    ra.step as resource_aggregations_step    
FROM test_workflow_executions e
LEFT JOIN test_workflow_results r ON e.id = r.execution_id
LEFT JOIN test_workflows w ON e.id = w.execution_id AND w.workflow_type = 'workflow'
LEFT JOIN test_workflows rw ON e.id = rw.execution_id AND rw.workflow_type = 'resolved_workflow'
LEFT JOIN test_workflow_resource_aggregations ra ON e.id = ra.execution_id
WHERE r.status = 'queued'
    AND (e.runner_id IS NULL OR e.runner_id = '')
ORDER BY e.id DESC
`

type GetUnassignedTestWorkflowExecutionsRow GetTestWorkflowExecutionRow

func (q *Queries) GetUnassignedTestWorkflowExecutions(ctx context.Context) ([]GetUnassignedTestWorkflowExecutionsRow, error) {
	rows, err := q.db.Query(ctx, getUnassignedTestWorkflowExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnassignedTestWorkflowExecutionsRow
	for rows.Next() {
		var i GetUnassignedTestWorkflowExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.PredictedStatus,
			&i.QueuedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Duration,
			&i.TotalDuration,
			&i.DurationMs,
			&i.PausedMs,
			&i.TotalDurationMs,
			&i.Pauses,
			&i.Initialization,
			&i.Steps,
			&i.WorkflowName,
			&i.WorkflowNamespace,
			&i.WorkflowDescription,
			&i.WorkflowLabels,
			&i.WorkflowAnnotations,
			&i.WorkflowCreated,
			&i.WorkflowUpdated,
			&i.WorkflowSpec,
			&i.WorkflowReadOnly,
			&i.WorkflowStatus,
			&i.WorkflowHealth,
			&i.ResolvedWorkflowName,
			&i.ResolvedWorkflowNamespace,
			&i.ResolvedWorkflowDescription,
			&i.ResolvedWorkflowLabels,
			&i.ResolvedWorkflowAnnotations,
			&i.ResolvedWorkflowCreated,
			&i.ResolvedWorkflowUpdated,
			&i.ResolvedWorkflowSpec,
			&i.ResolvedWorkflowReadOnly,
			&i.ResolvedWorkflowStatus,
			&i.SignaturesJson,
			&i.OutputsJson,
			&i.ReportsJson,
			&i.ResourceAggregationsGlobal,
			&i.ResourceAggregationsStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initTestWorkflowExecution = `-- name: InitTestWorkflowExecution :exec
UPDATE test_workflow_executions 
SET 
    namespace = $1,
    runner_id = $2
WHERE id = $3
`

type InitTestWorkflowExecutionParams struct {
	Namespace pgtype.Text `db:"namespace" json:"namespace"`
	RunnerID  pgtype.Text `db:"runner_id" json:"runner_id"`
	ID        string      `db:"id" json:"id"`
}

func (q *Queries) InitTestWorkflowExecution(ctx context.Context, arg InitTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, initTestWorkflowExecution, arg.Namespace, arg.RunnerID, arg.ID)
	return err
}

const insertTestWorkflow = `-- name: InsertTestWorkflow :exec
INSERT INTO test_workflows (
    execution_id, workflow_type, name, namespace, description, labels, annotations,
    created, updated, spec, read_only, status, health
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13
)
ON CONFLICT (execution_id, workflow_type) DO UPDATE SET
    name = EXCLUDED.name,
    namespace = EXCLUDED.namespace,
    description = EXCLUDED.description,
    labels = EXCLUDED.labels,
    annotations = EXCLUDED.annotations,
    created = EXCLUDED.created,
    updated = EXCLUDED.updated,
    spec = EXCLUDED.spec,
    read_only = EXCLUDED.read_only,
    status = EXCLUDED.status,
    health = EXCLUDED.health
`

type InsertTestWorkflowParams struct {
	ExecutionID  string             `db:"execution_id" json:"execution_id"`
	WorkflowType string             `db:"workflow_type" json:"workflow_type"`
	Name         pgtype.Text        `db:"name" json:"name"`
	Namespace    pgtype.Text        `db:"namespace" json:"namespace"`
	Description  pgtype.Text        `db:"description" json:"description"`
	Labels       []byte             `db:"labels" json:"labels"`
	Annotations  []byte             `db:"annotations" json:"annotations"`
	Created      pgtype.Timestamptz `db:"created" json:"created"`
	Updated      pgtype.Timestamptz `db:"updated" json:"updated"`
	Spec         []byte             `db:"spec" json:"spec"`
	ReadOnly     pgtype.Bool        `db:"read_only" json:"read_only"`
	Status       []byte             `db:"status" json:"status"`
	Health       []byte             `db:"health" json:"health"`
}

func (q *Queries) InsertTestWorkflow(ctx context.Context, arg InsertTestWorkflowParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflow,
		arg.ExecutionID,
		arg.WorkflowType,
		arg.Name,
		arg.Namespace,
		arg.Description,
		arg.Labels,
		arg.Annotations,
		arg.Created,
		arg.Updated,
		arg.Spec,
		arg.ReadOnly,
		arg.Status,
		arg.Health,
	)
	return err
}

const insertTestWorkflowExecution = `-- name: InsertTestWorkflowExecution :exec
INSERT INTO test_workflow_executions (
    id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number,
    scheduled_at, assigned_at, status_at, test_workflow_execution_name, disable_webhooks, 
    tags, running_context, config_params
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13,
    $14, $15, $16
)
`

type InsertTestWorkflowExecutionParams struct {
	ID                        string             `db:"id" json:"id"`
	GroupID                   pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID                  pgtype.Text        `db:"runner_id" json:"runner_id"`
	RunnerTarget              []byte             `db:"runner_target" json:"runner_target"`
	RunnerOriginalTarget      []byte             `db:"runner_original_target" json:"runner_original_target"`
	Name                      string             `db:"name" json:"name"`
	Namespace                 pgtype.Text        `db:"namespace" json:"namespace"`
	Number                    pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt               pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	AssignedAt                pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	StatusAt                  pgtype.Timestamptz `db:"status_at" json:"status_at"`
	TestWorkflowExecutionName pgtype.Text        `db:"test_workflow_execution_name" json:"test_workflow_execution_name"`
	DisableWebhooks           pgtype.Bool        `db:"disable_webhooks" json:"disable_webhooks"`
	Tags                      []byte             `db:"tags" json:"tags"`
	RunningContext            []byte             `db:"running_context" json:"running_context"`
	ConfigParams              []byte             `db:"config_params" json:"config_params"`
}

func (q *Queries) InsertTestWorkflowExecution(ctx context.Context, arg InsertTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowExecution,
		arg.ID,
		arg.GroupID,
		arg.RunnerID,
		arg.RunnerTarget,
		arg.RunnerOriginalTarget,
		arg.Name,
		arg.Namespace,
		arg.Number,
		arg.ScheduledAt,
		arg.AssignedAt,
		arg.StatusAt,
		arg.TestWorkflowExecutionName,
		arg.DisableWebhooks,
		arg.Tags,
		arg.RunningContext,
		arg.ConfigParams,
	)
	return err
}

const insertTestWorkflowOutput = `-- name: InsertTestWorkflowOutput :exec
INSERT INTO test_workflow_outputs (execution_id, ref, name, value)
VALUES ($1, $2, $3, $4)
`

type InsertTestWorkflowOutputParams struct {
	ExecutionID string      `db:"execution_id" json:"execution_id"`
	Ref         pgtype.Text `db:"ref" json:"ref"`
	Name        pgtype.Text `db:"name" json:"name"`
	Value       []byte      `db:"value" json:"value"`
}

func (q *Queries) InsertTestWorkflowOutput(ctx context.Context, arg InsertTestWorkflowOutputParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowOutput,
		arg.ExecutionID,
		arg.Ref,
		arg.Name,
		arg.Value,
	)
	return err
}

const insertTestWorkflowReport = `-- name: InsertTestWorkflowReport :exec
INSERT INTO test_workflow_reports (execution_id, ref, kind, file, summary)
VALUES ($1, $2, $3, $4, $5)
`

type InsertTestWorkflowReportParams struct {
	ExecutionID string      `db:"execution_id" json:"execution_id"`
	Ref         pgtype.Text `db:"ref" json:"ref"`
	Kind        pgtype.Text `db:"kind" json:"kind"`
	File        pgtype.Text `db:"file" json:"file"`
	Summary     []byte      `db:"summary" json:"summary"`
}

func (q *Queries) InsertTestWorkflowReport(ctx context.Context, arg InsertTestWorkflowReportParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowReport,
		arg.ExecutionID,
		arg.Ref,
		arg.Kind,
		arg.File,
		arg.Summary,
	)
	return err
}

const insertTestWorkflowResourceAggregations = `-- name: InsertTestWorkflowResourceAggregations :exec
INSERT INTO test_workflow_resource_aggregations (execution_id, global, step)
VALUES ($1, $2, $3)
ON CONFLICT (execution_id) DO UPDATE SET
    global = EXCLUDED.global,
    step = EXCLUDED.step
`

type InsertTestWorkflowResourceAggregationsParams struct {
	ExecutionID string `db:"execution_id" json:"execution_id"`
	Global      []byte `db:"global" json:"global"`
	Step        []byte `db:"step" json:"step"`
}

func (q *Queries) InsertTestWorkflowResourceAggregations(ctx context.Context, arg InsertTestWorkflowResourceAggregationsParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowResourceAggregations, arg.ExecutionID, arg.Global, arg.Step)
	return err
}

const insertTestWorkflowResult = `-- name: InsertTestWorkflowResult :exec
INSERT INTO test_workflow_results (
    execution_id, status, predicted_status, queued_at, started_at, finished_at,
    duration, total_duration, duration_ms, paused_ms, total_duration_ms,
    pauses, initialization, steps
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14
)
ON CONFLICT (execution_id) DO UPDATE SET
    status = EXCLUDED.status,
    predicted_status = EXCLUDED.predicted_status,
    queued_at = EXCLUDED.queued_at,
    started_at = EXCLUDED.started_at,
    finished_at = EXCLUDED.finished_at,
    duration = EXCLUDED.duration,
    total_duration = EXCLUDED.total_duration,
    duration_ms = EXCLUDED.duration_ms,
    paused_ms = EXCLUDED.paused_ms,
    total_duration_ms = EXCLUDED.total_duration_ms,
    pauses = EXCLUDED.pauses,
    initialization = EXCLUDED.initialization,
    steps = EXCLUDED.steps
`

type InsertTestWorkflowResultParams struct {
	ExecutionID     string             `db:"execution_id" json:"execution_id"`
	Status          pgtype.Text        `db:"status" json:"status"`
	PredictedStatus pgtype.Text        `db:"predicted_status" json:"predicted_status"`
	QueuedAt        pgtype.Timestamptz `db:"queued_at" json:"queued_at"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt      pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	Duration        pgtype.Text        `db:"duration" json:"duration"`
	TotalDuration   pgtype.Text        `db:"total_duration" json:"total_duration"`
	DurationMs      pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	PausedMs        pgtype.Int4        `db:"paused_ms" json:"paused_ms"`
	TotalDurationMs pgtype.Int4        `db:"total_duration_ms" json:"total_duration_ms"`
	Pauses          []byte             `db:"pauses" json:"pauses"`
	Initialization  []byte             `db:"initialization" json:"initialization"`
	Steps           []byte             `db:"steps" json:"steps"`
}

func (q *Queries) InsertTestWorkflowResult(ctx context.Context, arg InsertTestWorkflowResultParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowResult,
		arg.ExecutionID,
		arg.Status,
		arg.PredictedStatus,
		arg.QueuedAt,
		arg.StartedAt,
		arg.FinishedAt,
		arg.Duration,
		arg.TotalDuration,
		arg.DurationMs,
		arg.PausedMs,
		arg.TotalDurationMs,
		arg.Pauses,
		arg.Initialization,
		arg.Steps,
	)
	return err
}

const insertTestWorkflowSignature = `-- name: InsertTestWorkflowSignature :one
INSERT INTO test_workflow_signatures (
    execution_id, ref, name, category, optional, negative, parent_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING test_workflow_signatures.id
`

type InsertTestWorkflowSignatureParams struct {
	ExecutionID string      `db:"execution_id" json:"execution_id"`
	Ref         pgtype.Text `db:"ref" json:"ref"`
	Name        pgtype.Text `db:"name" json:"name"`
	Category    pgtype.Text `db:"category" json:"category"`
	Optional    pgtype.Bool `db:"optional" json:"optional"`
	Negative    pgtype.Bool `db:"negative" json:"negative"`
	ParentID    pgtype.Int4 `db:"parent_id" json:"parent_id"`
}

func (q *Queries) InsertTestWorkflowSignature(ctx context.Context, arg InsertTestWorkflowSignatureParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTestWorkflowSignature,
		arg.ExecutionID,
		arg.Ref,
		arg.Name,
		arg.Category,
		arg.Optional,
		arg.Negative,
		arg.ParentID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateExecutionStatusAt = `-- name: UpdateExecutionStatusAt :exec
UPDATE test_workflow_executions 
SET status_at = $1
WHERE id = $2
`

type UpdateExecutionStatusAtParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) UpdateExecutionStatusAt(ctx context.Context, arg UpdateExecutionStatusAtParams) error {
	_, err := q.db.Exec(ctx, updateExecutionStatusAt, arg.StatusAt, arg.ExecutionID)
	return err
}

const updateTestWorkflowExecution = `-- name: UpdateTestWorkflowExecution :exec
UPDATE test_workflow_executions
SET
    group_id = $1,
    runner_id = $2,
    runner_target = $3,
    runner_original_target = $4,
    name = $5,
    namespace = $6,
    number = $7,
    scheduled_at = $8,
    assigned_at = $9,
    status_at = $10,
    test_workflow_execution_name = $11,
    disable_webhooks = $12,
    tags = $13,
    running_context = $14,
    config_params = $15
WHERE id = $16
`

type UpdateTestWorkflowExecutionParams struct {
	GroupID                   pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID                  pgtype.Text        `db:"runner_id" json:"runner_id"`
	RunnerTarget              []byte             `db:"runner_target" json:"runner_target"`
	RunnerOriginalTarget      []byte             `db:"runner_original_target" json:"runner_original_target"`
	Name                      string             `db:"name" json:"name"`
	Namespace                 pgtype.Text        `db:"namespace" json:"namespace"`
	Number                    pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt               pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	AssignedAt                pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	StatusAt                  pgtype.Timestamptz `db:"status_at" json:"status_at"`
	TestWorkflowExecutionName pgtype.Text        `db:"test_workflow_execution_name" json:"test_workflow_execution_name"`
	DisableWebhooks           pgtype.Bool        `db:"disable_webhooks" json:"disable_webhooks"`
	Tags                      []byte             `db:"tags" json:"tags"`
	RunningContext            []byte             `db:"running_context" json:"running_context"`
	ConfigParams              []byte             `db:"config_params" json:"config_params"`
	ID                        string             `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecution(ctx context.Context, arg UpdateTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecution,
		arg.GroupID,
		arg.RunnerID,
		arg.RunnerTarget,
		arg.RunnerOriginalTarget,
		arg.Name,
		arg.Namespace,
		arg.Number,
		arg.ScheduledAt,
		arg.AssignedAt,
		arg.StatusAt,
		arg.TestWorkflowExecutionName,
		arg.DisableWebhooks,
		arg.Tags,
		arg.RunningContext,
		arg.ConfigParams,
		arg.ID,
	)
	return err
}

const updateTestWorkflowExecutionReport = `-- name: UpdateTestWorkflowExecutionReport :exec
INSERT INTO test_workflow_reports (execution_id, ref, kind, file, summary)
VALUES ($1, $2, $3, $4, $5)
`

type UpdateTestWorkflowExecutionReportParams struct {
	ExecutionID string      `db:"execution_id" json:"execution_id"`
	Ref         pgtype.Text `db:"ref" json:"ref"`
	Kind        pgtype.Text `db:"kind" json:"kind"`
	File        pgtype.Text `db:"file" json:"file"`
	Summary     []byte      `db:"summary" json:"summary"`
}

func (q *Queries) UpdateTestWorkflowExecutionReport(ctx context.Context, arg UpdateTestWorkflowExecutionReportParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionReport,
		arg.ExecutionID,
		arg.Ref,
		arg.Kind,
		arg.File,
		arg.Summary,
	)
	return err
}

const updateTestWorkflowExecutionResourceAggregations = `-- name: UpdateTestWorkflowExecutionResourceAggregations :exec
UPDATE test_workflow_resource_aggregations 
SET 
    global = $1,
    step = $2
WHERE execution_id = $3
`

type UpdateTestWorkflowExecutionResourceAggregationsParams struct {
	Global      []byte `db:"global" json:"global"`
	Step        []byte `db:"step" json:"step"`
	ExecutionID string `db:"execution_id" json:"execution_id"`
}

func (q *Queries) UpdateTestWorkflowExecutionResourceAggregations(ctx context.Context, arg UpdateTestWorkflowExecutionResourceAggregationsParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionResourceAggregations, arg.Global, arg.Step, arg.ExecutionID)
	return err
}

const updateTestWorkflowExecutionResult = `-- name: UpdateTestWorkflowExecutionResult :exec
UPDATE test_workflow_results 
SET 
    status = $1,
    predicted_status = $2,
    queued_at = $3,
    started_at = $4,
    finished_at = $5,
    duration = $6,
    total_duration = $7,
    duration_ms = $8,
    paused_ms = $9,
    total_duration_ms = $10,
    pauses = $11,
    initialization = $12,
    steps = $13
WHERE execution_id = $14
`

type UpdateTestWorkflowExecutionResultParams struct {
	Status          pgtype.Text        `db:"status" json:"status"`
	PredictedStatus pgtype.Text        `db:"predicted_status" json:"predicted_status"`
	QueuedAt        pgtype.Timestamptz `db:"queued_at" json:"queued_at"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt      pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	Duration        pgtype.Text        `db:"duration" json:"duration"`
	TotalDuration   pgtype.Text        `db:"total_duration" json:"total_duration"`
	DurationMs      pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	PausedMs        pgtype.Int4        `db:"paused_ms" json:"paused_ms"`
	TotalDurationMs pgtype.Int4        `db:"total_duration_ms" json:"total_duration_ms"`
	Pauses          []byte             `db:"pauses" json:"pauses"`
	Initialization  []byte             `db:"initialization" json:"initialization"`
	Steps           []byte             `db:"steps" json:"steps"`
	ExecutionID     string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) UpdateTestWorkflowExecutionResult(ctx context.Context, arg UpdateTestWorkflowExecutionResultParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionResult,
		arg.Status,
		arg.PredictedStatus,
		arg.QueuedAt,
		arg.StartedAt,
		arg.FinishedAt,
		arg.Duration,
		arg.TotalDuration,
		arg.DurationMs,
		arg.PausedMs,
		arg.TotalDurationMs,
		arg.Pauses,
		arg.Initialization,
		arg.Steps,
		arg.ExecutionID,
	)
	return err
}
