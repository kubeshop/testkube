// Code generated by AI Assistant

package sqlc

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pashagolub/pgxmock/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestSQLCLeaseQueries_FindLeaseById tests the FindLeaseById query syntax
func TestSQLCLeaseQueries_FindLeaseById(t *testing.T) {
	// Create mock database connection
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	// Define expected query pattern
	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
WHERE id = \$1`

	// Mock expected result
	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-cluster123", "test-identifier", "cluster123", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs("lease-cluster123").WillReturnRows(rows)

	// Execute query
	result, err := queries.FindLeaseById(ctx, "lease-cluster123")

	// Assertions
	assert.NoError(t, err)
	assert.Equal(t, "lease-cluster123", result.ID)
	assert.Equal(t, "test-identifier", result.Identifier)
	assert.Equal(t, "cluster123", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_InsertLease(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `INSERT INTO leases \(id, identifier, cluster_id, acquired_at, renewed_at\)
VALUES \(\$1, \$2, \$3, \$4, \$5\)
RETURNING id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at`

	testTime := time.Now()
	params := InsertLeaseParams{
		ID:         "lease-test-cluster",
		Identifier: "test-identifier",
		ClusterID:  "test-cluster",
		AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
		RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
	}

	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-test-cluster", "test-identifier", "test-cluster", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs(
		params.ID, params.Identifier, params.ClusterID, params.AcquiredAt, params.RenewedAt,
	).WillReturnRows(rows)

	result, err := queries.InsertLease(ctx, params)

	assert.NoError(t, err)
	assert.Equal(t, "lease-test-cluster", result.ID)
	assert.Equal(t, "test-identifier", result.Identifier)
	assert.Equal(t, "test-cluster", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_UpdateLease(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `UPDATE leases 
SET 
    identifier = \$1,
    cluster_id = \$2,
    acquired_at = \$3,
    renewed_at = \$4,
    updated_at = NOW\(\)
WHERE id = \$5
RETURNING id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at`

	testTime := time.Now()
	params := UpdateLeaseParams{
		Identifier: "updated-identifier",
		ClusterID:  "updated-cluster",
		AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
		RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
		ID:         "lease-test-cluster",
	}

	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-test-cluster", "updated-identifier", "updated-cluster", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs(
		params.Identifier, params.ClusterID, params.AcquiredAt, params.RenewedAt, params.ID,
	).WillReturnRows(rows)

	result, err := queries.UpdateLease(ctx, params)

	assert.NoError(t, err)
	assert.Equal(t, "lease-test-cluster", result.ID)
	assert.Equal(t, "updated-identifier", result.Identifier)
	assert.Equal(t, "updated-cluster", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_UpsertLease(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `INSERT INTO leases \(id, identifier, cluster_id, acquired_at, renewed_at\)
VALUES \(\$1, \$2, \$3, \$4, \$5\)
ON CONFLICT \(id\) DO UPDATE SET
    identifier = EXCLUDED\.identifier,
    cluster_id = EXCLUDED\.cluster_id,
    acquired_at = EXCLUDED\.acquired_at,
    renewed_at = EXCLUDED\.renewed_at,
    updated_at = NOW\(\)
RETURNING id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at`

	testTime := time.Now()
	params := UpsertLeaseParams{
		ID:         "lease-upsert-test",
		Identifier: "upsert-identifier",
		ClusterID:  "upsert-cluster",
		AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
		RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
	}

	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-upsert-test", "upsert-identifier", "upsert-cluster", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs(
		params.ID, params.Identifier, params.ClusterID, params.AcquiredAt, params.RenewedAt,
	).WillReturnRows(rows)

	result, err := queries.UpsertLease(ctx, params)

	assert.NoError(t, err)
	assert.Equal(t, "lease-upsert-test", result.ID)
	assert.Equal(t, "upsert-identifier", result.Identifier)
	assert.Equal(t, "upsert-cluster", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_GetLeaseByClusterId(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
WHERE cluster_id = \$1`

	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-target-cluster", "target-identifier", "target-cluster", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs("target-cluster").WillReturnRows(rows)

	result, err := queries.GetLeaseByClusterId(ctx, "target-cluster")

	assert.NoError(t, err)
	assert.Equal(t, "lease-target-cluster", result.ID)
	assert.Equal(t, "target-identifier", result.Identifier)
	assert.Equal(t, "target-cluster", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_GetLeasesByIdentifier(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
WHERE identifier = \$1
ORDER BY renewed_at DESC`

	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-cluster1", "common-identifier", "cluster1", testTime, testTime, testTime, testTime,
	).AddRow(
		"lease-cluster2", "common-identifier", "cluster2", testTime.Add(-time.Hour), testTime.Add(-time.Hour), testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs("common-identifier").WillReturnRows(rows)

	result, err := queries.GetLeasesByIdentifier(ctx, "common-identifier")

	assert.NoError(t, err)
	assert.Len(t, result, 2)
	assert.Equal(t, "lease-cluster1", result[0].ID)
	assert.Equal(t, "lease-cluster2", result[1].ID)
	assert.Equal(t, "common-identifier", result[0].Identifier)
	assert.Equal(t, "common-identifier", result[1].Identifier)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_GetExpiredLeases(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
WHERE renewed_at < \$1
ORDER BY renewed_at ASC`

	expirationTime := time.Now().Add(-24 * time.Hour)
	expiredTime := expirationTime.Add(-time.Hour)

	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-expired1", "expired-id1", "expired-cluster1", expiredTime, expiredTime, expiredTime, expiredTime,
	).AddRow(
		"lease-expired2", "expired-id2", "expired-cluster2", expiredTime, expiredTime, expiredTime, expiredTime,
	)

	expirationTimestamp := pgtype.Timestamptz{Time: expirationTime, Valid: true}
	mock.ExpectQuery(expectedQuery).WithArgs(expirationTimestamp).WillReturnRows(rows)

	result, err := queries.GetExpiredLeases(ctx, expirationTimestamp)

	assert.NoError(t, err)
	assert.Len(t, result, 2)
	assert.Equal(t, "lease-expired1", result[0].ID)
	assert.Equal(t, "lease-expired2", result[1].ID)
	assert.True(t, result[0].RenewedAt.Time.Before(expirationTime))
	assert.True(t, result[1].RenewedAt.Time.Before(expirationTime))
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_DeleteLease(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `DELETE FROM leases WHERE id = \$1`

	mock.ExpectExec(expectedQuery).WithArgs("lease-to-delete").WillReturnResult(pgxmock.NewResult("DELETE", 1))

	err = queries.DeleteLease(ctx, "lease-to-delete")

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_DeleteLeasesByClusterId(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `DELETE FROM leases WHERE cluster_id = \$1`

	mock.ExpectExec(expectedQuery).WithArgs("cluster-to-delete").WillReturnResult(pgxmock.NewResult("DELETE", 3))

	err = queries.DeleteLeasesByClusterId(ctx, "cluster-to-delete")

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_DeleteExpiredLeases(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `DELETE FROM leases WHERE renewed_at < \$1`

	expirationTime := time.Now().Add(-24 * time.Hour)
	expirationTimestamp := pgtype.Timestamptz{Time: expirationTime, Valid: true}

	mock.ExpectExec(expectedQuery).WithArgs(expirationTimestamp).WillReturnResult(pgxmock.NewResult("DELETE", 5))

	err = queries.DeleteExpiredLeases(ctx, expirationTimestamp)

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_GetAllLeases(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
ORDER BY renewed_at DESC`

	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-1", "identifier-1", "cluster-1", testTime, testTime, testTime, testTime,
	).AddRow(
		"lease-2", "identifier-2", "cluster-2", testTime.Add(-time.Hour), testTime.Add(-time.Hour), testTime, testTime,
	).AddRow(
		"lease-3", "identifier-3", "cluster-3", testTime.Add(-2*time.Hour), testTime.Add(-2*time.Hour), testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WillReturnRows(rows)

	result, err := queries.GetAllLeases(ctx)

	assert.NoError(t, err)
	assert.Len(t, result, 3)
	assert.Equal(t, "lease-1", result[0].ID)
	assert.Equal(t, "lease-2", result[1].ID)
	assert.Equal(t, "lease-3", result[2].ID)
	// Verify ordering by renewed_at DESC
	assert.True(t, result[0].RenewedAt.Time.After(result[1].RenewedAt.Time) || result[0].RenewedAt.Time.Equal(result[1].RenewedAt.Time))
	assert.True(t, result[1].RenewedAt.Time.After(result[2].RenewedAt.Time) || result[1].RenewedAt.Time.Equal(result[2].RenewedAt.Time))
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_CountLeasesByClusterId(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT COUNT\(\*\) FROM leases WHERE cluster_id = \$1`

	rows := mock.NewRows([]string{"count"}).AddRow(int64(42))

	mock.ExpectQuery(expectedQuery).WithArgs("test-cluster").WillReturnRows(rows)

	result, err := queries.CountLeasesByClusterId(ctx, "test-cluster")

	assert.NoError(t, err)
	assert.Equal(t, int64(42), result)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestSQLCLeaseQueries_GetLatestLeaseByIdentifierAndCluster(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at
FROM leases 
WHERE identifier = \$1 AND cluster_id = \$2
ORDER BY renewed_at DESC
LIMIT 1`

	testTime := time.Now()
	params := GetLatestLeaseByIdentifierAndClusterParams{
		Identifier: "specific-identifier",
		ClusterID:  "specific-cluster",
	}

	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	}).AddRow(
		"lease-specific", "specific-identifier", "specific-cluster", testTime, testTime, testTime, testTime,
	)

	mock.ExpectQuery(expectedQuery).WithArgs(params.Identifier, params.ClusterID).WillReturnRows(rows)

	result, err := queries.GetLatestLeaseByIdentifierAndCluster(ctx, params)

	assert.NoError(t, err)
	assert.Equal(t, "lease-specific", result.ID)
	assert.Equal(t, "specific-identifier", result.Identifier)
	assert.Equal(t, "specific-cluster", result.ClusterID)
	assert.NoError(t, mock.ExpectationsWereMet())
}

// Test with various edge cases and data types
func TestSQLCLeaseQueries_EdgeCases(t *testing.T) {
	tests := []struct {
		name          string
		setupMock     func(pgxmock.PgxPoolIface)
		executeQuery  func(*Queries, context.Context) error
		expectedError bool
	}{
		{
			name: "FindLeaseById - Record not found",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				mock.ExpectQuery(`SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at FROM leases WHERE id = \$1`).
					WithArgs("nonexistent").
					WillReturnError(errors.New(""))
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				_, err := q.FindLeaseById(ctx, "nonexistent")
				return err
			},
			expectedError: true,
		},
		{
			name: "DeleteLease - No rows affected",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				mock.ExpectExec(`DELETE FROM leases WHERE id = \$1`).
					WithArgs("nonexistent").
					WillReturnResult(pgxmock.NewResult("DELETE", 0))
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				return q.DeleteLease(ctx, "nonexistent")
			},
			expectedError: false, // DELETE with 0 rows is not an error in PostgreSQL
		},
		{
			name: "InsertLease - Constraint violation",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				mock.ExpectQuery(`INSERT INTO leases`).
					WithArgs("duplicate-id", "identifier", "cluster", pgtype.Timestamptz{}, pgtype.Timestamptz{}).
					WillReturnError(errors.New(""))
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				_, err := q.InsertLease(ctx, InsertLeaseParams{
					ID:         "duplicate-id",
					Identifier: "identifier",
					ClusterID:  "cluster",
					AcquiredAt: pgtype.Timestamptz{},
					RenewedAt:  pgtype.Timestamptz{},
				})
				return err
			},
			expectedError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mock, err := pgxmock.NewPool()
			require.NoError(t, err)
			defer mock.Close()

			queries := New(mock)
			ctx := context.Background()

			tt.setupMock(mock)

			err = tt.executeQuery(queries, ctx)

			if tt.expectedError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

// Test query parameter validation with various data types
func TestSQLCLeaseQueries_ParameterValidation(t *testing.T) {
	testTime := time.Now()
	tests := []struct {
		name          string
		setupMock     func(pgxmock.PgxPoolIface)
		executeQuery  func(*Queries, context.Context) error
		expectedError bool
	}{
		{
			name: "InsertLease with empty strings should work",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				rows := mock.NewRows([]string{
					"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
				}).AddRow("", "", "", testTime, testTime, testTime, testTime)

				mock.ExpectQuery(`INSERT INTO leases`).
					WithArgs("", "", "", pgtype.Timestamptz{Time: testTime, Valid: true}, pgtype.Timestamptz{Time: testTime, Valid: true}).
					WillReturnRows(rows)
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				_, err := q.InsertLease(ctx, InsertLeaseParams{
					ID:         "",
					Identifier: "",
					ClusterID:  "",
					AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
					RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
				})
				return err
			},
			expectedError: false,
		},
		{
			name: "UpdateLease with very long strings",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				longString := string(make([]byte, 1000)) // Very long string
				rows := mock.NewRows([]string{
					"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
				}).AddRow("lease-id", longString, longString, testTime, testTime, testTime, testTime)

				mock.ExpectQuery(`UPDATE leases SET`).
					WithArgs(longString, longString, pgtype.Timestamptz{Time: testTime, Valid: true}, pgtype.Timestamptz{Time: testTime, Valid: true}, "lease-id").
					WillReturnRows(rows)
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				longString := string(make([]byte, 1000))
				_, err := q.UpdateLease(ctx, UpdateLeaseParams{
					Identifier: longString,
					ClusterID:  longString,
					AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
					RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
					ID:         "lease-id",
				})
				return err
			},
			expectedError: false,
		},
		{
			name: "GetExpiredLeases with future timestamp",
			setupMock: func(mock pgxmock.PgxPoolIface) {
				futureTime := testTime.Add(24 * time.Hour)
				rows := mock.NewRows([]string{
					"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
				})

				mock.ExpectQuery(`SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at FROM leases WHERE renewed_at < \$1 ORDER BY renewed_at ASC`).
					WithArgs(pgtype.Timestamptz{Time: futureTime, Valid: true}).
					WillReturnRows(rows)
			},
			executeQuery: func(q *Queries, ctx context.Context) error {
				futureTime := testTime.Add(24 * time.Hour)
				_, err := q.GetExpiredLeases(ctx, pgtype.Timestamptz{Time: futureTime, Valid: true})
				return err
			},
			expectedError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mock, err := pgxmock.NewPool()
			require.NoError(t, err)
			defer mock.Close()

			queries := New(mock)
			ctx := context.Background()

			tt.setupMock(mock)

			err = tt.executeQuery(queries, ctx)

			if tt.expectedError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

// Benchmark tests to validate query performance characteristics
func BenchmarkSQLCLeaseQueries_FindLeaseById(b *testing.B) {
	mock, err := pgxmock.NewPool()
	require.NoError(b, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	// Setup mock expectations
	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	})

	for i := 0; i < b.N; i++ {
		rows.AddRow("lease-test", "identifier", "cluster", testTime, testTime, testTime, testTime)
		mock.ExpectQuery(`SELECT`).WithArgs("lease-test").WillReturnRows(rows)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := queries.FindLeaseById(ctx, "lease-test")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSQLCLeaseQueries_UpsertLease(b *testing.B) {
	mock, err := pgxmock.NewPool()
	require.NoError(b, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	// Setup mock expectations
	testTime := time.Now()
	rows := mock.NewRows([]string{
		"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
	})

	for i := 0; i < b.N; i++ {
		rows.AddRow("lease-test", "identifier", "cluster", testTime, testTime, testTime, testTime)
		mock.ExpectQuery(`INSERT INTO leases`).
			WithArgs("lease-test", "identifier", "cluster", pgtype.Timestamptz{Time: testTime, Valid: true}, pgtype.Timestamptz{Time: testTime, Valid: true}).
			WillReturnRows(rows)
	}

	params := UpsertLeaseParams{
		ID:         "lease-test",
		Identifier: "identifier",
		ClusterID:  "cluster",
		AcquiredAt: pgtype.Timestamptz{Time: testTime, Valid: true},
		RenewedAt:  pgtype.Timestamptz{Time: testTime, Valid: true},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := queries.UpsertLease(ctx, params)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// Test query result mapping with various timestamp scenarios
func TestSQLCLeaseQueries_TimestampHandling(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	// Test with various timestamp scenarios
	testCases := []struct {
		name       string
		acquiredAt time.Time
		renewedAt  time.Time
		createdAt  time.Time
		updatedAt  time.Time
	}{
		{
			name:       "Current timestamps",
			acquiredAt: time.Now(),
			renewedAt:  time.Now(),
			createdAt:  time.Now(),
			updatedAt:  time.Now(),
		},
		{
			name:       "Past timestamps",
			acquiredAt: time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC),
			renewedAt:  time.Date(2020, 1, 2, 0, 0, 0, 0, time.UTC),
			createdAt:  time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC),
			updatedAt:  time.Date(2020, 1, 2, 0, 0, 0, 0, time.UTC),
		},
		{
			name:       "Future timestamps",
			acquiredAt: time.Date(2030, 12, 31, 23, 59, 59, 0, time.UTC),
			renewedAt:  time.Date(2030, 12, 31, 23, 59, 59, 0, time.UTC),
			createdAt:  time.Date(2030, 12, 31, 23, 59, 59, 0, time.UTC),
			updatedAt:  time.Date(2030, 12, 31, 23, 59, 59, 0, time.UTC),
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at FROM leases WHERE id = \$1`

			rows := mock.NewRows([]string{
				"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
			}).AddRow(
				"lease-timestamp-test", "test-identifier", "test-cluster",
				tc.acquiredAt, tc.renewedAt, tc.createdAt, tc.updatedAt,
			)

			mock.ExpectQuery(expectedQuery).WithArgs("lease-timestamp-test").WillReturnRows(rows)

			result, err := queries.FindLeaseById(ctx, "lease-timestamp-test")

			assert.NoError(t, err)
			assert.Equal(t, "lease-timestamp-test", result.ID)
			assert.Equal(t, "test-identifier", result.Identifier)
			assert.Equal(t, "test-cluster", result.ClusterID)
			assert.True(t, tc.acquiredAt.Equal(result.AcquiredAt.Time))
			assert.True(t, tc.renewedAt.Equal(result.RenewedAt.Time))
			assert.True(t, tc.createdAt.Equal(result.CreatedAt.Time))
			assert.True(t, tc.updatedAt.Equal(result.UpdatedAt.Time))
		})
	}

	assert.NoError(t, mock.ExpectationsWereMet())
}

// Test concurrent query execution simulation
func TestSQLCLeaseQueries_ConcurrentExecution(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	// Simulate multiple concurrent lease acquisitions
	expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at FROM leases WHERE cluster_id = \$1`

	testTime := time.Now()
	for i := 0; i < 5; i++ {
		rows := mock.NewRows([]string{
			"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
		}).AddRow(
			"lease-concurrent", "concurrent-identifier", "concurrent-cluster", testTime, testTime, testTime, testTime,
		)
		mock.ExpectQuery(expectedQuery).WithArgs("concurrent-cluster").WillReturnRows(rows)
	}

	// Execute multiple queries
	for i := 0; i < 5; i++ {
		result, err := queries.GetLeaseByClusterId(ctx, "concurrent-cluster")
		assert.NoError(t, err)
		assert.Equal(t, "lease-concurrent", result.ID)
		assert.Equal(t, "concurrent-identifier", result.Identifier)
		assert.Equal(t, "concurrent-cluster", result.ClusterID)
	}

	assert.NoError(t, mock.ExpectationsWereMet())
}

// Test complex query ordering and filtering
func TestSQLCLeaseQueries_ComplexQueries(t *testing.T) {
	mock, err := pgxmock.NewPool()
	require.NoError(t, err)
	defer mock.Close()

	queries := New(mock)
	ctx := context.Background()

	t.Run("GetLeasesByIdentifier - Ordering verification", func(t *testing.T) {
		expectedQuery := `SELECT id, identifier, cluster_id, acquired_at, renewed_at, created_at, updated_at FROM leases WHERE identifier = \$1 ORDER BY renewed_at DESC`

		// Create leases with different renewal times
		time1 := time.Date(2023, 1, 1, 10, 0, 0, 0, time.UTC)
		time2 := time.Date(2023, 1, 1, 11, 0, 0, 0, time.UTC)
		time3 := time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC)

		rows := mock.NewRows([]string{
			"id", "identifier", "cluster_id", "acquired_at", "renewed_at", "created_at", "updated_at",
		}).AddRow(
			"lease-3", "shared-id", "cluster-3", time3, time3, time3, time3, // Most recent
		).AddRow(
			"lease-2", "shared-id", "cluster-2", time2, time2, time2, time2, // Middle
		).AddRow(
			"lease-1", "shared-id", "cluster-1", time1, time1, time1, time1, // Oldest
		)

		mock.ExpectQuery(expectedQuery).WithArgs("shared-id").WillReturnRows(rows)

		result, err := queries.GetLeasesByIdentifier(ctx, "shared-id")

		assert.NoError(t, err)
		assert.Len(t, result, 3)

		// Verify descending order by renewed_at
		assert.Equal(t, "lease-3", result[0].ID)
		assert.Equal(t, "lease-2", result[1].ID)
		assert.Equal(t, "lease-1", result[2].ID)

		// Verify timestamp ordering
		assert.True(t, result[0].RenewedAt.Time.After(result[1].RenewedAt.Time))
		assert.True(t, result[1].RenewedAt.Time.After(result[2].RenewedAt.Time))
	})

	assert.NoError(t, mock.ExpectationsWereMet())
}
