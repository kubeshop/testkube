// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: executions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const abortTestWorkflowExecutionIfQueued = `-- name: AbortTestWorkflowExecutionIfQueued :one
UPDATE test_workflow_executions 
SET 
    result = jsonb_set(
        jsonb_set(
            jsonb_set(
                jsonb_set(
                    jsonb_set(
                        jsonb_set(result, '{status}', '"aborted"'),
                        '{predictedstatus}', '"aborted"'
                    ),
                    '{finishedat}', to_jsonb($1::timestamp)
                ),
                '{initialization,status}', '"aborted"'
            ),
            '{initialization,errormessage}', '"Aborted before initialization."'
        ),
        '{initialization,finishedat}', to_jsonb($1::timestamp)
    ),
    status_at = $1
WHERE id = $2
    AND result->>'status' IN ('queued', 'running', 'paused')
    AND (runner_id IS NULL OR runner_id = '')
RETURNING id
`

type AbortTestWorkflowExecutionIfQueuedParams struct {
	AbortTime pgtype.Timestamptz `db:"abort_time" json:"abort_time"`
	ID        string             `db:"id" json:"id"`
}

func (q *Queries) AbortTestWorkflowExecutionIfQueued(ctx context.Context, arg AbortTestWorkflowExecutionIfQueuedParams) (string, error) {
	row := q.db.QueryRow(ctx, abortTestWorkflowExecutionIfQueued, arg.AbortTime, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const assignTestWorkflowExecution = `-- name: AssignTestWorkflowExecution :one
UPDATE test_workflow_executions 
SET 
    runner_id = $1,
    assigned_at = $2
WHERE id = $3
    AND result->>'status' = 'queued'
    AND (runner_id = $4 OR runner_id = $1 OR runner_id IS NULL)
RETURNING id
`

type AssignTestWorkflowExecutionParams struct {
	NewRunnerID  pgtype.Text        `db:"new_runner_id" json:"new_runner_id"`
	AssignedAt   pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	ID           string             `db:"id" json:"id"`
	PrevRunnerID pgtype.Text        `db:"prev_runner_id" json:"prev_runner_id"`
}

func (q *Queries) AssignTestWorkflowExecution(ctx context.Context, arg AssignTestWorkflowExecutionParams) (string, error) {
	row := q.db.QueryRow(ctx, assignTestWorkflowExecution,
		arg.NewRunnerID,
		arg.AssignedAt,
		arg.ID,
		arg.PrevRunnerID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllTestWorkflowExecutions = `-- name: DeleteAllTestWorkflowExecutions :exec
DELETE FROM test_workflow_executions
`

func (q *Queries) DeleteAllTestWorkflowExecutions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllTestWorkflowExecutions)
	return err
}

const deleteTestWorkflowExecutionsByTestWorkflow = `-- name: DeleteTestWorkflowExecutionsByTestWorkflow :exec
DELETE FROM test_workflow_executions 
WHERE workflow->>'name' = $1
`

func (q *Queries) DeleteTestWorkflowExecutionsByTestWorkflow(ctx context.Context, workflowName []byte) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowExecutionsByTestWorkflow, workflowName)
	return err
}

const deleteTestWorkflowExecutionsByTestWorkflows = `-- name: DeleteTestWorkflowExecutionsByTestWorkflows :exec
DELETE FROM test_workflow_executions 
WHERE workflow->>'name' = ANY($1)
`

func (q *Queries) DeleteTestWorkflowExecutionsByTestWorkflows(ctx context.Context, workflowNames []byte) error {
	_, err := q.db.Exec(ctx, deleteTestWorkflowExecutionsByTestWorkflows, workflowNames)
	return err
}

const getLatestTestWorkflowExecutionByTestWorkflow = `-- name: GetLatestTestWorkflowExecutionByTestWorkflow :one
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE workflow->>'name' = $1 
ORDER BY status_at DESC 
LIMIT 1
`

func (q *Queries) GetLatestTestWorkflowExecutionByTestWorkflow(ctx context.Context, workflowName []byte) (TestWorkflowExecution, error) {
	row := q.db.QueryRow(ctx, getLatestTestWorkflowExecutionByTestWorkflow, workflowName)
	var i TestWorkflowExecution
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.Signature,
		&i.Result,
		&i.Output,
		&i.Reports,
		&i.ResourceAggregations,
		&i.Workflow,
		&i.ResolvedWorkflow,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestTestWorkflowExecutionsByTestWorkflows = `-- name: GetLatestTestWorkflowExecutionsByTestWorkflows :many
SELECT DISTINCT ON (workflow->>'name') id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at
FROM test_workflow_executions 
WHERE workflow->>'name' = ANY($1)
ORDER BY workflow->>'name', status_at DESC
`

func (q *Queries) GetLatestTestWorkflowExecutionsByTestWorkflows(ctx context.Context, workflowNames []byte) ([]TestWorkflowExecution, error) {
	rows, err := q.db.Query(ctx, getLatestTestWorkflowExecutionsByTestWorkflows, workflowNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowExecution
	for rows.Next() {
		var i TestWorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.Signature,
			&i.Result,
			&i.Output,
			&i.Reports,
			&i.ResourceAggregations,
			&i.Workflow,
			&i.ResolvedWorkflow,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextExecutionNumber = `-- name: GetNextExecutionNumber :one
SELECT nextval('test_workflow_execution_number_seq_' || $1) as number
`

func (q *Queries) GetNextExecutionNumber(ctx context.Context, workflowName pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getNextExecutionNumber, workflowName)
	var number int64
	err := row.Scan(&number)
	return number, err
}

const getPreviousFinishedState = `-- name: GetPreviousFinishedState :one
SELECT result->>'status' as status
FROM test_workflow_executions 
WHERE workflow->>'name' = $1
    AND (result->>'finishedAt')::timestamp < $2
    AND result->>'status' IN ('passed', 'failed', 'skipped', 'aborted', 'timeout')
ORDER BY (result->>'finishedAt')::timestamp DESC
LIMIT 1
`

type GetPreviousFinishedStateParams struct {
	WorkflowName []byte `db:"workflow_name" json:"workflow_name"`
	Date         []byte `db:"date" json:"date"`
}

func (q *Queries) GetPreviousFinishedState(ctx context.Context, arg GetPreviousFinishedStateParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getPreviousFinishedState, arg.WorkflowName, arg.Date)
	var status interface{}
	err := row.Scan(&status)
	return status, err
}

const getRunningTestWorkflowExecutions = `-- name: GetRunningTestWorkflowExecutions :many
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE result->>'status' IN ('paused', 'running', 'queued')
ORDER BY id DESC
`

func (q *Queries) GetRunningTestWorkflowExecutions(ctx context.Context) ([]TestWorkflowExecution, error) {
	rows, err := q.db.Query(ctx, getRunningTestWorkflowExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowExecution
	for rows.Next() {
		var i TestWorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.Signature,
			&i.Result,
			&i.Output,
			&i.Reports,
			&i.ResourceAggregations,
			&i.Workflow,
			&i.ResolvedWorkflow,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecution = `-- name: GetTestWorkflowExecution :one
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE id = $1 OR name = $1
`

func (q *Queries) GetTestWorkflowExecution(ctx context.Context, id string) (TestWorkflowExecution, error) {
	row := q.db.QueryRow(ctx, getTestWorkflowExecution, id)
	var i TestWorkflowExecution
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.Signature,
		&i.Result,
		&i.Output,
		&i.Reports,
		&i.ResourceAggregations,
		&i.Workflow,
		&i.ResolvedWorkflow,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestWorkflowExecutionByNameAndTestWorkflow = `-- name: GetTestWorkflowExecutionByNameAndTestWorkflow :one
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE (id = $1 OR name = $1) AND workflow->>'name' = $2
`

type GetTestWorkflowExecutionByNameAndTestWorkflowParams struct {
	Name         string `db:"name" json:"name"`
	WorkflowName []byte `db:"workflow_name" json:"workflow_name"`
}

func (q *Queries) GetTestWorkflowExecutionByNameAndTestWorkflow(ctx context.Context, arg GetTestWorkflowExecutionByNameAndTestWorkflowParams) (TestWorkflowExecution, error) {
	row := q.db.QueryRow(ctx, getTestWorkflowExecutionByNameAndTestWorkflow, arg.Name, arg.WorkflowName)
	var i TestWorkflowExecution
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.Signature,
		&i.Result,
		&i.Output,
		&i.Reports,
		&i.ResourceAggregations,
		&i.Workflow,
		&i.ResolvedWorkflow,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestWorkflowExecutionTags = `-- name: GetTestWorkflowExecutionTags :many
SELECT 
    tag_key,
    array_agg(DISTINCT tag_value) as values
FROM (
    SELECT 
        t.key as tag_key,
        t.value as tag_value
    FROM test_workflow_executions,
         jsonb_each_text(tags) as t(key, value)
    WHERE tags IS NOT NULL AND tags != '{}'::jsonb
        AND ($1 IS NULL OR workflow->>'name' = $1)
) t
GROUP BY tag_key
`

type GetTestWorkflowExecutionTagsRow struct {
	TagKey interface{} `db:"tag_key" json:"tag_key"`
	Values interface{} `db:"values" json:"values"`
}

func (q *Queries) GetTestWorkflowExecutionTags(ctx context.Context, workflowName interface{}) ([]GetTestWorkflowExecutionTagsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionTags, workflowName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionTagsRow
	for rows.Next() {
		var i GetTestWorkflowExecutionTagsRow
		if err := rows.Scan(&i.TagKey, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutions = `-- name: GetTestWorkflowExecutions :many
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE 1=1
    AND ($1 IS NULL OR workflow->>'name' = $1)
    AND ($2 IS NULL OR workflow->>'name' = ANY($2))
    AND ($3 IS NULL OR name ILIKE '%' || $3 || '%')
    AND ($4 IS NULL OR scheduled_at >= $4)
    AND ($5 IS NULL OR scheduled_at <= $5)
    AND ($6 IS NULL OR scheduled_at >= NOW() - INTERVAL '@last_n_days days')
    AND ($7 IS NULL OR result->>'status' = ANY($7))
    AND ($8 IS NULL OR runner_id = $8)
    AND ($9 IS NULL OR 
         ($9 = true AND runner_id IS NOT NULL AND runner_id != '') OR 
         ($9 = false AND (runner_id IS NULL OR runner_id = '')))
    AND ($10 IS NULL OR running_context->'actor'->>'name' = $10)
    AND ($11 IS NULL OR running_context->'actor'->>'type_' = $11)
    AND ($12 IS NULL OR id = $12 OR group_id = $12)
    AND ($13 IS NULL OR 
         ($13 = true AND (result->>'status' != 'queued' OR result->'steps' IS NOT NULL)) OR
         ($13 = false AND result->>'status' = 'queued' AND (result->'steps' IS NULL OR result->'steps' = '{}'::jsonb)))
ORDER BY scheduled_at DESC
LIMIT $15 OFFSET $14
`

type GetTestWorkflowExecutionsParams struct {
	WorkflowName  interface{} `db:"workflow_name" json:"workflow_name"`
	WorkflowNames interface{} `db:"workflow_names" json:"workflow_names"`
	TextSearch    interface{} `db:"text_search" json:"text_search"`
	StartDate     interface{} `db:"start_date" json:"start_date"`
	EndDate       interface{} `db:"end_date" json:"end_date"`
	LastNDays     interface{} `db:"last_n_days" json:"last_n_days"`
	Statuses      interface{} `db:"statuses" json:"statuses"`
	RunnerID      interface{} `db:"runner_id" json:"runner_id"`
	Assigned      interface{} `db:"assigned" json:"assigned"`
	ActorName     interface{} `db:"actor_name" json:"actor_name"`
	ActorType     interface{} `db:"actor_type" json:"actor_type"`
	GroupID       interface{} `db:"group_id" json:"group_id"`
	Initialized   interface{} `db:"initialized" json:"initialized"`
	Ofst          int32       `db:"ofst" json:"ofst"`
	Lmt           int32       `db:"lmt" json:"lmt"`
}

func (q *Queries) GetTestWorkflowExecutions(ctx context.Context, arg GetTestWorkflowExecutionsParams) ([]TestWorkflowExecution, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutions,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.Ofst,
		arg.Lmt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowExecution
	for rows.Next() {
		var i TestWorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.Signature,
			&i.Result,
			&i.Output,
			&i.Reports,
			&i.ResourceAggregations,
			&i.Workflow,
			&i.ResolvedWorkflow,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutionsSummary = `-- name: GetTestWorkflowExecutionsSummary :many
SELECT 
    id, group_id, runner_id, name, number, scheduled_at, status_at,
    result, workflow, tags, running_context, config_params, reports, resource_aggregations
FROM test_workflow_executions 
WHERE 1=1
    AND ($1 IS NULL OR workflow->>'name' = $1)
    AND ($2 IS NULL OR workflow->>'name' = ANY($2))
    AND ($3 IS NULL OR name ILIKE '%' || $3 || '%')
    AND ($4 IS NULL OR scheduled_at >= $4)
    AND ($5 IS NULL OR scheduled_at <= $5)
    AND ($6 IS NULL OR scheduled_at >= NOW() - INTERVAL '@last_n_days days')
    AND ($7 IS NULL OR result->>'status' = ANY($7))
    AND ($8 IS NULL OR runner_id = $8)
    AND ($9 IS NULL OR 
         ($9 = true AND runner_id IS NOT NULL AND runner_id != '') OR 
         ($9 = false AND (runner_id IS NULL OR runner_id = '')))
    AND ($10 IS NULL OR running_context->'actor'->>'name' = $10)
    AND ($11 IS NULL OR running_context->'actor'->>'type_' = $11)
    AND ($12 IS NULL OR id = $12 OR group_id = $12)
    AND ($13 IS NULL OR 
         ($13 = true AND (result->>'status' != 'queued' OR result->'steps' IS NOT NULL)) OR
         ($13 = false AND result->>'status' = 'queued' AND (result->'steps' IS NULL OR result->'steps' = '{}'::jsonb)))
ORDER BY scheduled_at DESC
LIMIT $15 OFFSET $14
`

type GetTestWorkflowExecutionsSummaryParams struct {
	WorkflowName  interface{} `db:"workflow_name" json:"workflow_name"`
	WorkflowNames interface{} `db:"workflow_names" json:"workflow_names"`
	TextSearch    interface{} `db:"text_search" json:"text_search"`
	StartDate     interface{} `db:"start_date" json:"start_date"`
	EndDate       interface{} `db:"end_date" json:"end_date"`
	LastNDays     interface{} `db:"last_n_days" json:"last_n_days"`
	Statuses      interface{} `db:"statuses" json:"statuses"`
	RunnerID      interface{} `db:"runner_id" json:"runner_id"`
	Assigned      interface{} `db:"assigned" json:"assigned"`
	ActorName     interface{} `db:"actor_name" json:"actor_name"`
	ActorType     interface{} `db:"actor_type" json:"actor_type"`
	GroupID       interface{} `db:"group_id" json:"group_id"`
	Initialized   interface{} `db:"initialized" json:"initialized"`
	Ofst          int32       `db:"ofst" json:"ofst"`
	Lmt           int32       `db:"lmt" json:"lmt"`
}

type GetTestWorkflowExecutionsSummaryRow struct {
	ID                   string             `db:"id" json:"id"`
	GroupID              pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID             pgtype.Text        `db:"runner_id" json:"runner_id"`
	Name                 string             `db:"name" json:"name"`
	Number               pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt          pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	StatusAt             pgtype.Timestamptz `db:"status_at" json:"status_at"`
	Result               []byte             `db:"result" json:"result"`
	Workflow             []byte             `db:"workflow" json:"workflow"`
	Tags                 []byte             `db:"tags" json:"tags"`
	RunningContext       []byte             `db:"running_context" json:"running_context"`
	ConfigParams         []byte             `db:"config_params" json:"config_params"`
	Reports              []byte             `db:"reports" json:"reports"`
	ResourceAggregations []byte             `db:"resource_aggregations" json:"resource_aggregations"`
}

func (q *Queries) GetTestWorkflowExecutionsSummary(ctx context.Context, arg GetTestWorkflowExecutionsSummaryParams) ([]GetTestWorkflowExecutionsSummaryRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionsSummary,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
		arg.Ofst,
		arg.Lmt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionsSummaryRow
	for rows.Next() {
		var i GetTestWorkflowExecutionsSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.Name,
			&i.Number,
			&i.ScheduledAt,
			&i.StatusAt,
			&i.Result,
			&i.Workflow,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.Reports,
			&i.ResourceAggregations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowExecutionsTotals = `-- name: GetTestWorkflowExecutionsTotals :many
SELECT 
    result->>'status' as status,
    COUNT(*) as count
FROM test_workflow_executions 
WHERE 1=1
    AND ($1 IS NULL OR workflow->>'name' = $1)
    AND ($2 IS NULL OR workflow->>'name' = ANY($2))
    AND ($3 IS NULL OR name ILIKE '%' || $3 || '%')
    AND ($4 IS NULL OR scheduled_at >= $4)
    AND ($5 IS NULL OR scheduled_at <= $5)
    AND ($6 IS NULL OR scheduled_at >= NOW() - INTERVAL '@last_n_days days')
    AND ($7 IS NULL OR result->>'status' = ANY($7))
    AND ($8 IS NULL OR runner_id = $8)
    AND ($9 IS NULL OR 
         ($9 = true AND runner_id IS NOT NULL AND runner_id != '') OR 
         ($9 = false AND (runner_id IS NULL OR runner_id = '')))
    AND ($10 IS NULL OR running_context->'actor'->>'name' = $10)
    AND ($11 IS NULL OR running_context->'actor'->>'type_' = $11)
    AND ($12 IS NULL OR id = $12 OR group_id = $12)
    AND ($13 IS NULL OR 
         ($13 = true AND (result->>'status' != 'queued' OR result->'steps' IS NOT NULL)) OR
         ($13 = false AND result->>'status' = 'queued' AND (result->'steps' IS NULL OR result->'steps' = '{}'::jsonb)))
GROUP BY result->>'status'
`

type GetTestWorkflowExecutionsTotalsParams struct {
	WorkflowName  interface{} `db:"workflow_name" json:"workflow_name"`
	WorkflowNames interface{} `db:"workflow_names" json:"workflow_names"`
	TextSearch    interface{} `db:"text_search" json:"text_search"`
	StartDate     interface{} `db:"start_date" json:"start_date"`
	EndDate       interface{} `db:"end_date" json:"end_date"`
	LastNDays     interface{} `db:"last_n_days" json:"last_n_days"`
	Statuses      interface{} `db:"statuses" json:"statuses"`
	RunnerID      interface{} `db:"runner_id" json:"runner_id"`
	Assigned      interface{} `db:"assigned" json:"assigned"`
	ActorName     interface{} `db:"actor_name" json:"actor_name"`
	ActorType     interface{} `db:"actor_type" json:"actor_type"`
	GroupID       interface{} `db:"group_id" json:"group_id"`
	Initialized   interface{} `db:"initialized" json:"initialized"`
}

type GetTestWorkflowExecutionsTotalsRow struct {
	Status interface{} `db:"status" json:"status"`
	Count  int64       `db:"count" json:"count"`
}

func (q *Queries) GetTestWorkflowExecutionsTotals(ctx context.Context, arg GetTestWorkflowExecutionsTotalsParams) ([]GetTestWorkflowExecutionsTotalsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowExecutionsTotals,
		arg.WorkflowName,
		arg.WorkflowNames,
		arg.TextSearch,
		arg.StartDate,
		arg.EndDate,
		arg.LastNDays,
		arg.Statuses,
		arg.RunnerID,
		arg.Assigned,
		arg.ActorName,
		arg.ActorType,
		arg.GroupID,
		arg.Initialized,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowExecutionsTotalsRow
	for rows.Next() {
		var i GetTestWorkflowExecutionsTotalsRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestWorkflowMetrics = `-- name: GetTestWorkflowMetrics :many
SELECT 
    id as execution_id,
    group_id,
    result->>'duration' as duration,
    result->>'durationms' as duration_ms,
    result->>'status' as status,
    name,
    scheduled_at as start_time,
    runner_id
FROM test_workflow_executions 
WHERE workflow->>'name' = $1
    AND ($2 = 0 OR scheduled_at >= NOW() - INTERVAL '@last_days days')
ORDER BY scheduled_at DESC
LIMIT $3
`

type GetTestWorkflowMetricsParams struct {
	WorkflowName []byte      `db:"workflow_name" json:"workflow_name"`
	LastDays     interface{} `db:"last_days" json:"last_days"`
	Lmt          int32       `db:"lmt" json:"lmt"`
}

type GetTestWorkflowMetricsRow struct {
	ExecutionID string             `db:"execution_id" json:"execution_id"`
	GroupID     pgtype.Text        `db:"group_id" json:"group_id"`
	Duration    interface{}        `db:"duration" json:"duration"`
	DurationMs  interface{}        `db:"duration_ms" json:"duration_ms"`
	Status      interface{}        `db:"status" json:"status"`
	Name        string             `db:"name" json:"name"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	RunnerID    pgtype.Text        `db:"runner_id" json:"runner_id"`
}

func (q *Queries) GetTestWorkflowMetrics(ctx context.Context, arg GetTestWorkflowMetricsParams) ([]GetTestWorkflowMetricsRow, error) {
	rows, err := q.db.Query(ctx, getTestWorkflowMetrics, arg.WorkflowName, arg.LastDays, arg.Lmt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestWorkflowMetricsRow
	for rows.Next() {
		var i GetTestWorkflowMetricsRow
		if err := rows.Scan(
			&i.ExecutionID,
			&i.GroupID,
			&i.Duration,
			&i.DurationMs,
			&i.Status,
			&i.Name,
			&i.StartTime,
			&i.RunnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnassignedTestWorkflowExecutions = `-- name: GetUnassignedTestWorkflowExecutions :many
SELECT id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations, workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at FROM test_workflow_executions 
WHERE result->>'status' = 'queued'
    AND (runner_id IS NULL OR runner_id = '')
ORDER BY id DESC
`

func (q *Queries) GetUnassignedTestWorkflowExecutions(ctx context.Context) ([]TestWorkflowExecution, error) {
	rows, err := q.db.Query(ctx, getUnassignedTestWorkflowExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowExecution
	for rows.Next() {
		var i TestWorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.RunnerID,
			&i.RunnerTarget,
			&i.RunnerOriginalTarget,
			&i.Name,
			&i.Namespace,
			&i.Number,
			&i.ScheduledAt,
			&i.AssignedAt,
			&i.StatusAt,
			&i.Signature,
			&i.Result,
			&i.Output,
			&i.Reports,
			&i.ResourceAggregations,
			&i.Workflow,
			&i.ResolvedWorkflow,
			&i.TestWorkflowExecutionName,
			&i.DisableWebhooks,
			&i.Tags,
			&i.RunningContext,
			&i.ConfigParams,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initTestWorkflowExecution = `-- name: InitTestWorkflowExecution :exec
UPDATE test_workflow_executions 
SET 
    namespace = $1,
    signature = $2,
    runner_id = $3
WHERE id = $4
`

type InitTestWorkflowExecutionParams struct {
	Namespace pgtype.Text `db:"namespace" json:"namespace"`
	Signature []byte      `db:"signature" json:"signature"`
	RunnerID  pgtype.Text `db:"runner_id" json:"runner_id"`
	ID        string      `db:"id" json:"id"`
}

func (q *Queries) InitTestWorkflowExecution(ctx context.Context, arg InitTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, initTestWorkflowExecution,
		arg.Namespace,
		arg.Signature,
		arg.RunnerID,
		arg.ID,
	)
	return err
}

const insertTestWorkflowExecution = `-- name: InsertTestWorkflowExecution :exec
INSERT INTO test_workflow_executions (
    id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number,
    scheduled_at, assigned_at, status_at, signature, result, output, reports, resource_aggregations,
    workflow, resolved_workflow, test_workflow_execution_name, disable_webhooks, tags, 
    running_context, config_params
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14, $15, $16,
    $17, $18, $19, $20, $21,
    $22, $23
)
`

type InsertTestWorkflowExecutionParams struct {
	ID                        string             `db:"id" json:"id"`
	GroupID                   pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID                  pgtype.Text        `db:"runner_id" json:"runner_id"`
	RunnerTarget              []byte             `db:"runner_target" json:"runner_target"`
	RunnerOriginalTarget      []byte             `db:"runner_original_target" json:"runner_original_target"`
	Name                      string             `db:"name" json:"name"`
	Namespace                 pgtype.Text        `db:"namespace" json:"namespace"`
	Number                    pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt               pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	AssignedAt                pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	StatusAt                  pgtype.Timestamptz `db:"status_at" json:"status_at"`
	Signature                 []byte             `db:"signature" json:"signature"`
	Result                    []byte             `db:"result" json:"result"`
	Output                    []byte             `db:"output" json:"output"`
	Reports                   []byte             `db:"reports" json:"reports"`
	ResourceAggregations      []byte             `db:"resource_aggregations" json:"resource_aggregations"`
	Workflow                  []byte             `db:"workflow" json:"workflow"`
	ResolvedWorkflow          []byte             `db:"resolved_workflow" json:"resolved_workflow"`
	TestWorkflowExecutionName pgtype.Text        `db:"test_workflow_execution_name" json:"test_workflow_execution_name"`
	DisableWebhooks           pgtype.Bool        `db:"disable_webhooks" json:"disable_webhooks"`
	Tags                      []byte             `db:"tags" json:"tags"`
	RunningContext            []byte             `db:"running_context" json:"running_context"`
	ConfigParams              []byte             `db:"config_params" json:"config_params"`
}

func (q *Queries) InsertTestWorkflowExecution(ctx context.Context, arg InsertTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, insertTestWorkflowExecution,
		arg.ID,
		arg.GroupID,
		arg.RunnerID,
		arg.RunnerTarget,
		arg.RunnerOriginalTarget,
		arg.Name,
		arg.Namespace,
		arg.Number,
		arg.ScheduledAt,
		arg.AssignedAt,
		arg.StatusAt,
		arg.Signature,
		arg.Result,
		arg.Output,
		arg.Reports,
		arg.ResourceAggregations,
		arg.Workflow,
		arg.ResolvedWorkflow,
		arg.TestWorkflowExecutionName,
		arg.DisableWebhooks,
		arg.Tags,
		arg.RunningContext,
		arg.ConfigParams,
	)
	return err
}

const updateTestWorkflowExecution = `-- name: UpdateTestWorkflowExecution :exec
UPDATE test_workflow_executions 
SET 
    group_id = $1,
    runner_id = $2,
    runner_target = $3,
    runner_original_target = $4,
    name = $5,
    namespace = $6,
    number = $7,
    scheduled_at = $8,
    assigned_at = $9,
    status_at = $10,
    signature = $11,
    result = $12,
    output = $13,
    reports = $14,
    resource_aggregations = $15,
    workflow = $16,
    resolved_workflow = $17,
    test_workflow_execution_name = $18,
    disable_webhooks = $19,
    tags = $20,
    running_context = $21,
    config_params = $22
WHERE id = $23
`

type UpdateTestWorkflowExecutionParams struct {
	GroupID                   pgtype.Text        `db:"group_id" json:"group_id"`
	RunnerID                  pgtype.Text        `db:"runner_id" json:"runner_id"`
	RunnerTarget              []byte             `db:"runner_target" json:"runner_target"`
	RunnerOriginalTarget      []byte             `db:"runner_original_target" json:"runner_original_target"`
	Name                      string             `db:"name" json:"name"`
	Namespace                 pgtype.Text        `db:"namespace" json:"namespace"`
	Number                    pgtype.Int4        `db:"number" json:"number"`
	ScheduledAt               pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	AssignedAt                pgtype.Timestamptz `db:"assigned_at" json:"assigned_at"`
	StatusAt                  pgtype.Timestamptz `db:"status_at" json:"status_at"`
	Signature                 []byte             `db:"signature" json:"signature"`
	Result                    []byte             `db:"result" json:"result"`
	Output                    []byte             `db:"output" json:"output"`
	Reports                   []byte             `db:"reports" json:"reports"`
	ResourceAggregations      []byte             `db:"resource_aggregations" json:"resource_aggregations"`
	Workflow                  []byte             `db:"workflow" json:"workflow"`
	ResolvedWorkflow          []byte             `db:"resolved_workflow" json:"resolved_workflow"`
	TestWorkflowExecutionName pgtype.Text        `db:"test_workflow_execution_name" json:"test_workflow_execution_name"`
	DisableWebhooks           pgtype.Bool        `db:"disable_webhooks" json:"disable_webhooks"`
	Tags                      []byte             `db:"tags" json:"tags"`
	RunningContext            []byte             `db:"running_context" json:"running_context"`
	ConfigParams              []byte             `db:"config_params" json:"config_params"`
	ID                        string             `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecution(ctx context.Context, arg UpdateTestWorkflowExecutionParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecution,
		arg.GroupID,
		arg.RunnerID,
		arg.RunnerTarget,
		arg.RunnerOriginalTarget,
		arg.Name,
		arg.Namespace,
		arg.Number,
		arg.ScheduledAt,
		arg.AssignedAt,
		arg.StatusAt,
		arg.Signature,
		arg.Result,
		arg.Output,
		arg.Reports,
		arg.ResourceAggregations,
		arg.Workflow,
		arg.ResolvedWorkflow,
		arg.TestWorkflowExecutionName,
		arg.DisableWebhooks,
		arg.Tags,
		arg.RunningContext,
		arg.ConfigParams,
		arg.ID,
	)
	return err
}

const updateTestWorkflowExecutionOutput = `-- name: UpdateTestWorkflowExecutionOutput :exec
UPDATE test_workflow_executions 
SET output = $1
WHERE id = $2
`

type UpdateTestWorkflowExecutionOutputParams struct {
	Output []byte `db:"output" json:"output"`
	ID     string `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecutionOutput(ctx context.Context, arg UpdateTestWorkflowExecutionOutputParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionOutput, arg.Output, arg.ID)
	return err
}

const updateTestWorkflowExecutionReport = `-- name: UpdateTestWorkflowExecutionReport :exec
UPDATE test_workflow_executions 
SET reports = COALESCE(reports, '[]'::jsonb) || $1::jsonb
WHERE id = $2
`

type UpdateTestWorkflowExecutionReportParams struct {
	Report []byte `db:"report" json:"report"`
	ID     string `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecutionReport(ctx context.Context, arg UpdateTestWorkflowExecutionReportParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionReport, arg.Report, arg.ID)
	return err
}

const updateTestWorkflowExecutionResourceAggregations = `-- name: UpdateTestWorkflowExecutionResourceAggregations :exec
UPDATE test_workflow_executions 
SET resource_aggregations = $1
WHERE id = $2
`

type UpdateTestWorkflowExecutionResourceAggregationsParams struct {
	ResourceAggregations []byte `db:"resource_aggregations" json:"resource_aggregations"`
	ID                   string `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecutionResourceAggregations(ctx context.Context, arg UpdateTestWorkflowExecutionResourceAggregationsParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionResourceAggregations, arg.ResourceAggregations, arg.ID)
	return err
}

const updateTestWorkflowExecutionResult = `-- name: UpdateTestWorkflowExecutionResult :exec
UPDATE test_workflow_executions 
SET 
    result = $1,
    status_at = CASE 
        WHEN $2 IS NOT NULL THEN $2 
        ELSE status_at 
    END
WHERE id = $3
`

type UpdateTestWorkflowExecutionResultParams struct {
	Result     []byte             `db:"result" json:"result"`
	FinishedAt pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ID         string             `db:"id" json:"id"`
}

func (q *Queries) UpdateTestWorkflowExecutionResult(ctx context.Context, arg UpdateTestWorkflowExecutionResultParams) error {
	_, err := q.db.Exec(ctx, updateTestWorkflowExecutionResult, arg.Result, arg.FinishedAt, arg.ID)
	return err
}
