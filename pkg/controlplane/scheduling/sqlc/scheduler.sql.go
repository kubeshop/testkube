// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scheduler.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignExecutionResult = `-- name: AssignExecutionResult :one
UPDATE test_workflow_results
SET
    status = 'assigned',
    updated_at = $1::timestamptz
WHERE execution_id = $2::text RETURNING execution_id, status, predicted_status, queued_at, started_at, finished_at, duration, total_duration, duration_ms, paused_ms, total_duration_ms, pauses, initialization, steps, created_at, updated_at
`

type AssignExecutionResultParams struct {
	Ts          pgtype.Timestamptz `db:"ts" json:"ts"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) AssignExecutionResult(ctx context.Context, arg AssignExecutionResultParams) (TestWorkflowResult, error) {
	row := q.db.QueryRow(ctx, assignExecutionResult, arg.Ts, arg.ExecutionID)
	var i TestWorkflowResult
	err := row.Scan(
		&i.ExecutionID,
		&i.Status,
		&i.PredictedStatus,
		&i.QueuedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Duration,
		&i.TotalDuration,
		&i.DurationMs,
		&i.PausedMs,
		&i.TotalDurationMs,
		&i.Pauses,
		&i.Initialization,
		&i.Steps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignExecutionRoot = `-- name: AssignExecutionRoot :one
UPDATE test_workflow_executions
SET
    runner_id = $1::text,
    status_at = $2::timestamptz,
    assigned_at = $2::timestamptz,
    updated_at = $2::timestamptz
WHERE id = $3::text RETURNING id, group_id, runner_id, runner_target, runner_original_target, name, namespace, number, scheduled_at, assigned_at, status_at, test_workflow_execution_name, disable_webhooks, tags, running_context, config_params, created_at, updated_at, organization_id, environment_id, runtime
`

type AssignExecutionRootParams struct {
	RunnerID    string             `db:"runner_id" json:"runner_id"`
	Ts          pgtype.Timestamptz `db:"ts" json:"ts"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) AssignExecutionRoot(ctx context.Context, arg AssignExecutionRootParams) (TestWorkflowExecution, error) {
	row := q.db.QueryRow(ctx, assignExecutionRoot, arg.RunnerID, arg.Ts, arg.ExecutionID)
	var i TestWorkflowExecution
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.RunnerID,
		&i.RunnerTarget,
		&i.RunnerOriginalTarget,
		&i.Name,
		&i.Namespace,
		&i.Number,
		&i.ScheduledAt,
		&i.AssignedAt,
		&i.StatusAt,
		&i.TestWorkflowExecutionName,
		&i.DisableWebhooks,
		&i.Tags,
		&i.RunningContext,
		&i.ConfigParams,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.EnvironmentID,
		&i.Runtime,
	)
	return i, err
}

const getExecutionAggregation = `-- name: GetExecutionAggregation :one
SELECT execution_id, global, step, created_at, updated_at
FROM test_workflow_resource_aggregations
WHERE execution_id = $1::text
`

func (q *Queries) GetExecutionAggregation(ctx context.Context, executionID string) (TestWorkflowResourceAggregation, error) {
	row := q.db.QueryRow(ctx, getExecutionAggregation, executionID)
	var i TestWorkflowResourceAggregation
	err := row.Scan(
		&i.ExecutionID,
		&i.Global,
		&i.Step,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExecutionOutputs = `-- name: GetExecutionOutputs :many
SELECT id, execution_id, ref, name, value, created_at
FROM test_workflow_outputs
WHERE execution_id = $1::text
`

func (q *Queries) GetExecutionOutputs(ctx context.Context, executionID string) ([]TestWorkflowOutput, error) {
	rows, err := q.db.Query(ctx, getExecutionOutputs, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowOutput
	for rows.Next() {
		var i TestWorkflowOutput
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionReports = `-- name: GetExecutionReports :many
SELECT id, execution_id, ref, kind, file, summary, created_at
FROM test_workflow_reports
WHERE execution_id = $1::text
`

func (q *Queries) GetExecutionReports(ctx context.Context, executionID string) ([]TestWorkflowReport, error) {
	rows, err := q.db.Query(ctx, getExecutionReports, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowReport
	for rows.Next() {
		var i TestWorkflowReport
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Kind,
			&i.File,
			&i.Summary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionResolvedWorkflow = `-- name: GetExecutionResolvedWorkflow :one
SELECT id, execution_id, workflow_type, name, namespace, description, labels, annotations, created, updated, spec, read_only, status, created_at, updated_at
FROM test_workflows
WHERE workflow_type = 'resolved_workflow' AND execution_id = $1::text
`

func (q *Queries) GetExecutionResolvedWorkflow(ctx context.Context, executionID string) (TestWorkflow, error) {
	row := q.db.QueryRow(ctx, getExecutionResolvedWorkflow, executionID)
	var i TestWorkflow
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.WorkflowType,
		&i.Name,
		&i.Namespace,
		&i.Description,
		&i.Labels,
		&i.Annotations,
		&i.Created,
		&i.Updated,
		&i.Spec,
		&i.ReadOnly,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExecutionSignatures = `-- name: GetExecutionSignatures :many
SELECT id, execution_id, ref, name, category, optional, negative, parent_id, created_at
FROM test_workflow_signatures
WHERE execution_id = $1::text
`

func (q *Queries) GetExecutionSignatures(ctx context.Context, executionID string) ([]TestWorkflowSignature, error) {
	rows, err := q.db.Query(ctx, getExecutionSignatures, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestWorkflowSignature
	for rows.Next() {
		var i TestWorkflowSignature
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.Ref,
			&i.Name,
			&i.Category,
			&i.Optional,
			&i.Negative,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionWorkflow = `-- name: GetExecutionWorkflow :one
SELECT id, execution_id, workflow_type, name, namespace, description, labels, annotations, created, updated, spec, read_only, status, created_at, updated_at
FROM test_workflows
WHERE workflow_type = 'workflow' AND execution_id = $1::text
`

func (q *Queries) GetExecutionWorkflow(ctx context.Context, executionID string) (TestWorkflow, error) {
	row := q.db.QueryRow(ctx, getExecutionWorkflow, executionID)
	var i TestWorkflow
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.WorkflowType,
		&i.Name,
		&i.Namespace,
		&i.Description,
		&i.Labels,
		&i.Annotations,
		&i.Created,
		&i.Updated,
		&i.Spec,
		&i.ReadOnly,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextExecution = `-- name: GetNextExecution :one
SELECT
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at, e.organization_id, e.environment_id, e.runtime,
    r.execution_id, r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at, r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms, r.pauses, r.initialization, r.steps, r.created_at, r.updated_at
FROM
    test_workflow_executions e
        JOIN test_workflow_results r ON e.id = r.execution_id
WHERE
    r.status IS NULL
   OR r.status IN ('queued', 'assigned', 'starting')
ORDER BY
    e.scheduled_at
LIMIT
    1
FOR UPDATE
`

type GetNextExecutionRow struct {
	TestWorkflowExecution TestWorkflowExecution `db:"test_workflow_execution" json:"test_workflow_execution"`
	TestWorkflowResult    TestWorkflowResult    `db:"test_workflow_result" json:"test_workflow_result"`
}

func (q *Queries) GetNextExecution(ctx context.Context) (GetNextExecutionRow, error) {
	row := q.db.QueryRow(ctx, getNextExecution)
	var i GetNextExecutionRow
	err := row.Scan(
		&i.TestWorkflowExecution.ID,
		&i.TestWorkflowExecution.GroupID,
		&i.TestWorkflowExecution.RunnerID,
		&i.TestWorkflowExecution.RunnerTarget,
		&i.TestWorkflowExecution.RunnerOriginalTarget,
		&i.TestWorkflowExecution.Name,
		&i.TestWorkflowExecution.Namespace,
		&i.TestWorkflowExecution.Number,
		&i.TestWorkflowExecution.ScheduledAt,
		&i.TestWorkflowExecution.AssignedAt,
		&i.TestWorkflowExecution.StatusAt,
		&i.TestWorkflowExecution.TestWorkflowExecutionName,
		&i.TestWorkflowExecution.DisableWebhooks,
		&i.TestWorkflowExecution.Tags,
		&i.TestWorkflowExecution.RunningContext,
		&i.TestWorkflowExecution.ConfigParams,
		&i.TestWorkflowExecution.CreatedAt,
		&i.TestWorkflowExecution.UpdatedAt,
		&i.TestWorkflowExecution.OrganizationID,
		&i.TestWorkflowExecution.EnvironmentID,
		&i.TestWorkflowExecution.Runtime,
		&i.TestWorkflowResult.ExecutionID,
		&i.TestWorkflowResult.Status,
		&i.TestWorkflowResult.PredictedStatus,
		&i.TestWorkflowResult.QueuedAt,
		&i.TestWorkflowResult.StartedAt,
		&i.TestWorkflowResult.FinishedAt,
		&i.TestWorkflowResult.Duration,
		&i.TestWorkflowResult.TotalDuration,
		&i.TestWorkflowResult.DurationMs,
		&i.TestWorkflowResult.PausedMs,
		&i.TestWorkflowResult.TotalDurationMs,
		&i.TestWorkflowResult.Pauses,
		&i.TestWorkflowResult.Initialization,
		&i.TestWorkflowResult.Steps,
		&i.TestWorkflowResult.CreatedAt,
		&i.TestWorkflowResult.UpdatedAt,
	)
	return i, err
}
