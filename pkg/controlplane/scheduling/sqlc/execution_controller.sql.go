// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: execution_controller.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const abortExecutionQueued = `-- name: AbortExecutionQueued :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status IN ('queued', 'assigned')
`

type AbortExecutionQueuedParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) AbortExecutionQueued(ctx context.Context, arg AbortExecutionQueuedParams) error {
	_, err := q.db.Exec(ctx, abortExecutionQueued, arg.StatusAt, arg.ExecutionID)
	return err
}

const abortExecutionQueuedResult = `-- name: AbortExecutionQueuedResult :exec
UPDATE test_workflow_results 
SET 
    status = 'aborted',
    predicted_status = 'aborted',
    finished_at = $1
WHERE execution_id = $2
  AND status IN ('queued', 'assigned')
`

type AbortExecutionQueuedResultParams struct {
	FinishedAt  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) AbortExecutionQueuedResult(ctx context.Context, arg AbortExecutionQueuedResultParams) error {
	_, err := q.db.Exec(ctx, abortExecutionQueuedResult, arg.FinishedAt, arg.ExecutionID)
	return err
}

const abortExecutionRunning = `-- name: AbortExecutionRunning :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status IN ('starting', 'scheduling', 'running', 'paused', 'resuming')
`

type AbortExecutionRunningParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) AbortExecutionRunning(ctx context.Context, arg AbortExecutionRunningParams) error {
	_, err := q.db.Exec(ctx, abortExecutionRunning, arg.StatusAt, arg.ExecutionID)
	return err
}

const abortExecutionRunningResult = `-- name: AbortExecutionRunningResult :exec
UPDATE test_workflow_results 
SET 
    status = 'stopping',
    predicted_status = 'aborted'
WHERE execution_id = $1
  AND status IN ('starting', 'scheduling', 'running', 'paused', 'resuming')
`

func (q *Queries) AbortExecutionRunningResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, abortExecutionRunningResult, executionID)
	return err
}

const cancelExecutionQueued = `-- name: CancelExecutionQueued :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status IN ('queued', 'assigned')
`

type CancelExecutionQueuedParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) CancelExecutionQueued(ctx context.Context, arg CancelExecutionQueuedParams) error {
	_, err := q.db.Exec(ctx, cancelExecutionQueued, arg.StatusAt, arg.ExecutionID)
	return err
}

const cancelExecutionQueuedResult = `-- name: CancelExecutionQueuedResult :exec
UPDATE test_workflow_results 
SET 
    status = 'canceled',
    predicted_status = 'canceled',
    finished_at = $1
WHERE execution_id = $2
  AND status IN ('queued', 'assigned')
`

type CancelExecutionQueuedResultParams struct {
	FinishedAt  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) CancelExecutionQueuedResult(ctx context.Context, arg CancelExecutionQueuedResultParams) error {
	_, err := q.db.Exec(ctx, cancelExecutionQueuedResult, arg.FinishedAt, arg.ExecutionID)
	return err
}

const cancelExecutionRunning = `-- name: CancelExecutionRunning :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status IN ('starting', 'scheduling', 'running', 'paused', 'resuming')
`

type CancelExecutionRunningParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) CancelExecutionRunning(ctx context.Context, arg CancelExecutionRunningParams) error {
	_, err := q.db.Exec(ctx, cancelExecutionRunning, arg.StatusAt, arg.ExecutionID)
	return err
}

const cancelExecutionRunningResult = `-- name: CancelExecutionRunningResult :exec
UPDATE test_workflow_results 
SET 
    status = 'stopping',
    predicted_status = 'canceled'
WHERE execution_id = $1
  AND status IN ('starting', 'scheduling', 'running', 'paused', 'resuming')
`

func (q *Queries) CancelExecutionRunningResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, cancelExecutionRunningResult, executionID)
	return err
}

const forceCancelExecution = `-- name: ForceCancelExecution :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status IN (
    'queued', 'assigned', 'starting', 'scheduling', 'running', 
    'pausing', 'paused', 'resuming', 'stopping'
  )
`

type ForceCancelExecutionParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

// Updates the execution status_at timestamp for executions in cancellable states
func (q *Queries) ForceCancelExecution(ctx context.Context, arg ForceCancelExecutionParams) error {
	_, err := q.db.Exec(ctx, forceCancelExecution, arg.StatusAt, arg.ExecutionID)
	return err
}

const forceCancelExecutionInitialization = `-- name: ForceCancelExecutionInitialization :exec
UPDATE test_workflow_results 
SET initialization = (
    CASE 
        -- If initialization is already passed or failed, keep it as is
        WHEN initialization->>'status' IN ('passed', 'failed') THEN initialization
        -- Otherwise, cancel it and update timestamps
        ELSE jsonb_build_object(
            'status', 'canceled',
            'queuedAt', COALESCE(
                NULLIF(initialization->>'queuedAt', '0001-01-01T00:00:00Z'),
                to_jsonb($1::timestamptz)
            ),
            'startedAt', COALESCE(
                NULLIF(initialization->>'startedAt', '0001-01-01T00:00:00Z'),
                to_jsonb($1::timestamptz)
            ),
            'finishedaAt', COALESCE(
                NULLIF(initialization->>'finishedAt', '0001-01-01T00:00:00Z'),
                to_jsonb($1::timestamptz)
            )
        ) || (initialization - ARRAY['status', 'queuedat', 'startedat', 'finishedat'])
    END
)
WHERE execution_id = $2
  AND initialization IS NOT NULL
  AND jsonb_typeof(initialization) = 'object'
  AND initialization->>'status' NOT IN ('passed', 'failed')
`

type ForceCancelExecutionInitializationParams struct {
	FinishedAt  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

// Cancels the initialization step if it's not already terminated
func (q *Queries) ForceCancelExecutionInitialization(ctx context.Context, arg ForceCancelExecutionInitializationParams) error {
	_, err := q.db.Exec(ctx, forceCancelExecutionInitialization, arg.FinishedAt, arg.ExecutionID)
	return err
}

const forceCancelExecutionResult = `-- name: ForceCancelExecutionResult :exec
UPDATE test_workflow_results 
SET 
    status = 'canceled',
    predicted_status = 'canceled',
    finished_at = $1
WHERE execution_id = $2
  AND status IN (
    'queued', 'assigned', 'starting', 'scheduling', 'running', 
    'pausing', 'paused', 'resuming', 'stopping'
  )
`

type ForceCancelExecutionResultParams struct {
	FinishedAt  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

// Updates the main result status and timestamps
func (q *Queries) ForceCancelExecutionResult(ctx context.Context, arg ForceCancelExecutionResultParams) error {
	_, err := q.db.Exec(ctx, forceCancelExecutionResult, arg.FinishedAt, arg.ExecutionID)
	return err
}

const forceCancelExecutionSteps = `-- name: ForceCancelExecutionSteps :exec
UPDATE test_workflow_results 
SET steps = (
    SELECT jsonb_object_agg(
        key,
        CASE 
            -- If step is already passed or failed, keep it as is
            WHEN value->>'status' IN ('passed', 'failed') THEN value
            -- Otherwise, cancel it and update timestamps
            ELSE jsonb_build_object(
                'status', 'canceled',
                'queuedAt', COALESCE(
                    NULLIF(value->>'queuedAt', '0001-01-01T00:00:00Z'),
                    to_jsonb($1::timestamptz)
                ),
                'startedAt', COALESCE(
                    NULLIF(value->>'startedAt', '0001-01-01T00:00:00Z'),
                    to_jsonb($1::timestamptz)
                ),
                'finishedAt', COALESCE(
                    NULLIF(value->>'finishedAt', '0001-01-01T00:00:00Z'),
                    to_jsonb($1::timestamptz)
                )
            ) || (value - ARRAY['status', 'queuedat', 'startedat', 'finishedat'])
        END
    )
    FROM jsonb_each(COALESCE(steps, '{}'::jsonb))
)
WHERE execution_id = $2
  AND steps IS NOT NULL
  AND jsonb_typeof(steps) = 'object'
`

type ForceCancelExecutionStepsParams struct {
	FinishedAt  pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

// Cancels all steps that are not already terminated (passed/failed)
// Sets missing timestamps (queuedat, startedat, finishedat) to the provided time
func (q *Queries) ForceCancelExecutionSteps(ctx context.Context, arg ForceCancelExecutionStepsParams) error {
	_, err := q.db.Exec(ctx, forceCancelExecutionSteps, arg.FinishedAt, arg.ExecutionID)
	return err
}

const getExecutionForceCancel = `-- name: GetExecutionForceCancel :one
SELECT 
    e.id,
    r.status
FROM test_workflow_executions e
INNER JOIN test_workflow_results r ON e.id = r.execution_id
WHERE e.id = $1
  AND r.status IN (
    'queued', 'assigned', 'starting', 'scheduling', 'running', 
    'pausing', 'paused', 'resuming', 'stopping'
  )
`

type GetExecutionForceCancelRow struct {
	ID     string      `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
}

// Helper query to verify the execution can be force-canceled
func (q *Queries) GetExecutionForceCancel(ctx context.Context, executionID string) (GetExecutionForceCancelRow, error) {
	row := q.db.QueryRow(ctx, getExecutionForceCancel, executionID)
	var i GetExecutionForceCancelRow
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const pauseExecution = `-- name: PauseExecution :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status = 'running'
`

type PauseExecutionParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) PauseExecution(ctx context.Context, arg PauseExecutionParams) error {
	_, err := q.db.Exec(ctx, pauseExecution, arg.StatusAt, arg.ExecutionID)
	return err
}

const pauseExecutionResult = `-- name: PauseExecutionResult :exec
UPDATE test_workflow_results 
SET status = 'pausing'
WHERE execution_id = $1
  AND status = 'running'
`

func (q *Queries) PauseExecutionResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, pauseExecutionResult, executionID)
	return err
}

const resumeExecution = `-- name: ResumeExecution :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status = 'paused'
`

type ResumeExecutionParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) ResumeExecution(ctx context.Context, arg ResumeExecutionParams) error {
	_, err := q.db.Exec(ctx, resumeExecution, arg.StatusAt, arg.ExecutionID)
	return err
}

const resumeExecutionResult = `-- name: ResumeExecutionResult :exec
UPDATE test_workflow_results 
SET status = 'resuming'
WHERE execution_id = $1
  AND status = 'paused'
`

func (q *Queries) ResumeExecutionResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, resumeExecutionResult, executionID)
	return err
}

const startExecution = `-- name: StartExecution :exec
UPDATE test_workflow_executions 
SET status_at = $1
FROM test_workflow_results r
WHERE test_workflow_executions.id = $2
  AND test_workflow_executions.id = r.execution_id
  AND r.status = 'assigned'
`

type StartExecutionParams struct {
	StatusAt    pgtype.Timestamptz `db:"status_at" json:"status_at"`
	ExecutionID string             `db:"execution_id" json:"execution_id"`
}

func (q *Queries) StartExecution(ctx context.Context, arg StartExecutionParams) error {
	_, err := q.db.Exec(ctx, startExecution, arg.StatusAt, arg.ExecutionID)
	return err
}

const startExecutionResult = `-- name: StartExecutionResult :exec
UPDATE test_workflow_results 
SET status = 'starting'
WHERE execution_id = $1
  AND status = 'assigned'
`

func (q *Queries) StartExecutionResult(ctx context.Context, executionID string) error {
	_, err := q.db.Exec(ctx, startExecutionResult, executionID)
	return err
}
