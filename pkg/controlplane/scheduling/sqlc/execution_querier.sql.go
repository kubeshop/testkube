// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: execution_querier.sql

package sqlc

import (
	"context"
)

const getExecutionsByStatus = `-- name: GetExecutionsByStatus :many
SELECT
    e.id, e.group_id, e.runner_id, e.runner_target, e.runner_original_target, e.name, e.namespace, e.number, e.scheduled_at, e.assigned_at, e.status_at, e.test_workflow_execution_name, e.disable_webhooks, e.tags, e.running_context, e.config_params, e.created_at, e.updated_at, e.organization_id, e.environment_id, e.runtime,
    r.execution_id, r.status, r.predicted_status, r.queued_at, r.started_at, r.finished_at, r.duration, r.total_duration, r.duration_ms, r.paused_ms, r.total_duration_ms, r.pauses, r.initialization, r.steps, r.created_at, r.updated_at
FROM
    test_workflow_executions e
        JOIN test_workflow_results r ON e.id = r.execution_id
WHERE r.status = $1::text
  AND (COALESCE($2::text, '') = '' OR predicted_status = $2::text)
ORDER BY e.scheduled_at
`

type GetExecutionsByStatusParams struct {
	Status          string `db:"status" json:"status"`
	PredictedStatus string `db:"predicted_status" json:"predicted_status"`
}

type GetExecutionsByStatusRow struct {
	TestWorkflowExecution TestWorkflowExecution `db:"test_workflow_execution" json:"test_workflow_execution"`
	TestWorkflowResult    TestWorkflowResult    `db:"test_workflow_result" json:"test_workflow_result"`
}

func (q *Queries) GetExecutionsByStatus(ctx context.Context, arg GetExecutionsByStatusParams) ([]GetExecutionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getExecutionsByStatus, arg.Status, arg.PredictedStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExecutionsByStatusRow
	for rows.Next() {
		var i GetExecutionsByStatusRow
		if err := rows.Scan(
			&i.TestWorkflowExecution.ID,
			&i.TestWorkflowExecution.GroupID,
			&i.TestWorkflowExecution.RunnerID,
			&i.TestWorkflowExecution.RunnerTarget,
			&i.TestWorkflowExecution.RunnerOriginalTarget,
			&i.TestWorkflowExecution.Name,
			&i.TestWorkflowExecution.Namespace,
			&i.TestWorkflowExecution.Number,
			&i.TestWorkflowExecution.ScheduledAt,
			&i.TestWorkflowExecution.AssignedAt,
			&i.TestWorkflowExecution.StatusAt,
			&i.TestWorkflowExecution.TestWorkflowExecutionName,
			&i.TestWorkflowExecution.DisableWebhooks,
			&i.TestWorkflowExecution.Tags,
			&i.TestWorkflowExecution.RunningContext,
			&i.TestWorkflowExecution.ConfigParams,
			&i.TestWorkflowExecution.CreatedAt,
			&i.TestWorkflowExecution.UpdatedAt,
			&i.TestWorkflowExecution.OrganizationID,
			&i.TestWorkflowExecution.EnvironmentID,
			&i.TestWorkflowExecution.Runtime,
			&i.TestWorkflowResult.ExecutionID,
			&i.TestWorkflowResult.Status,
			&i.TestWorkflowResult.PredictedStatus,
			&i.TestWorkflowResult.QueuedAt,
			&i.TestWorkflowResult.StartedAt,
			&i.TestWorkflowResult.FinishedAt,
			&i.TestWorkflowResult.Duration,
			&i.TestWorkflowResult.TotalDuration,
			&i.TestWorkflowResult.DurationMs,
			&i.TestWorkflowResult.PausedMs,
			&i.TestWorkflowResult.TotalDurationMs,
			&i.TestWorkflowResult.Pauses,
			&i.TestWorkflowResult.Initialization,
			&i.TestWorkflowResult.Steps,
			&i.TestWorkflowResult.CreatedAt,
			&i.TestWorkflowResult.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
