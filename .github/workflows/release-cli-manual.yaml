name: Manual CLI Release

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Are you sure you want to proceed with CLI release?'
        type: choice
        required: true
        options:
          - 'no'
          - 'yes'
      skip_build:
        description: 'Skip build/release and only publish Linux packages? (for re-runs when release exists)'
        type: boolean
        required: false
        default: false

permissions:
  id-token: write # needed for keyless signing
  contents: write

env:
  TESTKUBE_CHOCO_REPO: https://chocolatey.kubeshop.io/
  ALPINE_IMAGE: alpine:3.21.3
  BUSYBOX_IMAGE: busybox:1.36.1-musl

jobs:
  pre_build:
    name: Pre-build
    runs-on: depot-ubuntu-22.04
    if: ${{ inputs.confirm == 'yes' && !inputs.skip_build }}
    strategy:
      matrix:
        include:
          - name: "linux"
            path: .builds-linux.goreleaser.yml
          - name: "windows"
            path: .builds-windows.goreleaser.yml
          - name: "darwin"
            path: .builds-darwin.goreleaser.yml
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable
      - name: Go Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Get tag
        id: tag
        run: |
          # Find tag pointing to current commit
          TAG=$(git describe --tags --exact-match 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$TAG" ]; then
            echo "Error: No tag found"
            exit 1
          fi
          # Strip 'v' prefix if present
          TAG_STRIPPED=${TAG#v}
          echo "tag=$TAG_STRIPPED" >> $GITHUB_OUTPUT
          echo "Found tag: $TAG (stripped: $TAG_STRIPPED)"
      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: 'v2.3.2' # 2.4.4 fails with "no such file or directory"
          args: release -f ${{ matrix.path }} --skip=publish,validate
        env:
          GITHUB_TOKEN: ${{ secrets.CI_BOT_TOKEN }}
          ANALYTICS_TRACKING_ID: "${{secrets.TESTKUBE_CLI_GA_MEASUREMENT_ID}}"
          ANALYTICS_API_KEY: "${{secrets.TESTKUBE_CLI_GA_MEASUREMENT_SECRET}}"
          KEYGEN_PUBLIC_KEY: "${{secrets.KEYGEN_PUBLIC_KEY}}"
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
          DOCKER_BUILDX_BUILDER: "${{ steps.buildx.outputs.name }}"
          DOCKER_BUILDX_CACHE_FROM: "type=gha"
          DOCKER_BUILDX_CACHE_TO: "type=gha,mode=max"
          ALPINE_IMAGE: ${{ env.ALPINE_IMAGE }}
          BUSYBOX_IMAGE: ${{ env.BUSYBOX_IMAGE }}
          DOCKER_IMAGE_TAG: ${{steps.tag.outputs.tag}}
      - name: Upload Artifacts
        uses: actions/upload-artifact@master
        with:
          name: testkube_${{ matrix.name }}
          path: |
            ${{ matrix.name }}/testkube_${{ matrix.name }}_*
          retention-days: 1

  release:
    name: Create and upload release-artifacts
    needs: pre_build
    runs-on: depot-ubuntu-22.04
    if: ${{ inputs.confirm == 'yes' && !inputs.skip_build }}

    steps:
      - uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: 253113
          private-key: ${{ secrets.TESTKUBE_GH_APP_GITOPS_KEY }}
          owner: kubeshop
      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
      - name: Configure git
        run: |
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'
          git config --global url."https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/".insteadOf "https://github.com/"
      - uses: sigstore/cosign-installer@v3.8.2
      - uses: anchore/sbom-action/download-syft@v0.19.0
      - name: Download Artifacts for Linux
        uses: actions/download-artifact@master
        with:
          name: testkube_linux
          path: linux
      - name: Download Artifacts for Windows
        uses: actions/download-artifact@master
        with:
          name: testkube_windows
          path: windows
      - name: Download Artifacts for Darwin
        uses: actions/download-artifact@master
        with:
          name: testkube_darwin
          path: darwin
      # Added as a workaround since files lose their permissions when being moved from one stage to another in GH. A bug was reported
      # and will be fixed in the next release of GoReleaser, thus we will be able to remove this code.
      - name: Add executable mode
        run: chmod -R +x linux/ darwin/
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable
      - name: Go Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: 'v2.3.2' # 2.4.4 fails with "no such file or directory"
          args: release -f .goreleaser.yml --skip=validate
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          ANALYTICS_TRACKING_ID: "${{secrets.TESTKUBE_CLI_GA_MEASUREMENT_ID}}"
          ANALYTICS_API_KEY: "${{secrets.TESTKUBE_CLI_GA_MEASUREMENT_SECRET}}"
          SLACK_BOT_CLIENT_ID: "${{secrets.TESTKUBE_SLACK_BOT_CLIENT_ID}}"
          SLACK_BOT_CLIENT_SECRET: "${{secrets.TESTKUBE_SLACK_BOT_CLIENT_SECRET}}"
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Store Intermediate Artifacts
        uses: actions/upload-artifact@master
        with:
          name: bin-artifacts
          path: dist
          retention-days: 1

  build-and-publish-windows-installer:
    needs: release
    runs-on: windows-latest
    if: ${{ always() && inputs.confirm == 'yes' && (inputs.skip_build || needs.release.result == 'success') }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Get Intermediate Artifacts (from workflow)
        if: ${{ !inputs.skip_build }}
        uses: actions/download-artifact@master
        with:
          name: testkube_windows
          path: windows

      - name: Get tag
        id: tag
        shell: bash
        run: |
          # Find tag pointing to current commit
          TAG=$(git describe --tags --exact-match 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$TAG" ]; then
            echo "Error: No tag found"
            exit 1
          fi
          # Strip 'v' prefix if present
          TAG_STRIPPED=${TAG#v}
          echo "tag=$TAG_STRIPPED" >> $GITHUB_OUTPUT
          echo "Found tag: $TAG (stripped: $TAG_STRIPPED)"

      - name: Download Windows binary from GitHub Release
        if: ${{ inputs.skip_build }}
        shell: bash
        env:
          VERSION: ${{steps.tag.outputs.tag}}
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p windows/testkube_windows_386
          gh release download ${VERSION} --pattern "testkube_${VERSION}_Windows_i386.tar.gz" --dir windows/temp
          tar -xzf windows/temp/testkube_${VERSION}_Windows_i386.tar.gz -C windows/testkube_windows_386

      - name: Create and Sign MSI
        run: |
          Copy-Item 'windows\testkube_windows_386\kubectl-testkube.exe' '.\kubectl-testkube.exe'
          Copy-Item 'build\installer\windows\testkube.wxs' '.\testkube.wxs'
          Copy-Item 'build\installer\windows\tk.bat' '.\tk.bat'
          Copy-Item 'build\installer\windows\testkube.bat' '.\testkube.bat'
          & "$env:WIX\bin\candle.exe" *.wxs
          & "$env:WIX\bin\light.exe" *.wixobj

      - name: Sign Artifact with CodeSignTool
        uses: sslcom/esigner-codesign@develop
        with:
          command: sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          file_path: testkube.msi
          output_path: ${GITHUB_WORKSPACE}\artifacts
          malware_block: false

      - name: Get release
        id: get_release
        uses: bruceadams/get-release@v1.3.2
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Calculate Checksum
        id: checksum
        run: |
          $installer_name = $env:MSI_NAME
          $installer_path = $env:MSI_PATH
          $hash=Get-FileHash $installer_path
          $hash.Hash + "  " + $installer_name + ".msi" >> msi_checksum.txt
          echo "::set-output name=INSTALLER_NAME::${installer_name}"
          echo "::set-output name=INSTALLER_PATH::${installer_path}"

          #export MSI hash to environment
          $hashsum = $hash.Hash
          echo "::set-output name=CHECKSUM::${hashsum}"

          #copy MSI to choco directory to build a nuget package
          Copy-Item -Path "$installer_path" -Destination ".\choco\tools\$env:MSI_NAME.msi"
        env:
          MSI_NAME: testkube_${{steps.tag.outputs.tag}}_Windows_i386
          MSI_PATH: D:\a\testkube\testkube\artifacts\testkube.msi

      - name: Upload release binary
        uses: actions/upload-release-asset@v1.0.2
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          upload_url: ${{ steps.get_release.outputs.upload_url }}
          asset_path: ${{steps.checksum.outputs.INSTALLER_PATH}}
          asset_name: ${{steps.checksum.outputs.INSTALLER_NAME}}.msi
          asset_content_type: application/octet-stream

      - name: Upload Checksum
        uses: actions/upload-release-asset@v1.0.2
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          upload_url: ${{ steps.get_release.outputs.upload_url }}
          asset_path: msi_checksum.txt
          asset_name: ${{steps.checksum.outputs.INSTALLER_NAME}}_checksum.txt
          asset_content_type: text/plain

      - name: Update checksum in chocolateyInstall.ps1 file
        working-directory: ./choco
        run: |
          $file_content  = Get-Content .\tools\chocolateyInstall.ps1 -Raw
          $update_version = $file_content -replace "(?i)(\schecksum\s*=\s*)('.*')", "`$1'${{steps.checksum.outputs.CHECKSUM}}'"
          Set-Content -Path .\tools\chocolateyInstall.ps1 -Value $update_version -NoNewline

      - name: Bump versions and push package to chocolatey repo
        working-directory: ./choco
        run: |
          ./update.ps1 ${{steps.tag.outputs.tag}} ${{ secrets.COMMOM_CHOCO_API_KEY }} ${{ env.TESTKUBE_CHOCO_REPO }}

  build-and-publish-linux-installer:
    needs: release
    runs-on: depot-ubuntu-22.04
    if: ${{ always() && inputs.confirm == 'yes' && (inputs.skip_build || needs.release.result == 'success') }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Get Intermediate Artifacts (from workflow)
        if: ${{ !inputs.skip_build }}
        uses: actions/download-artifact@master
        with:
          name: bin-artifacts
          path: dist

      - name: Get tag
        id: tag
        run: |
          # Find tag pointing to current commit
          TAG=$(git describe --tags --exact-match 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$TAG" ]; then
            echo "Error: No tag found"
            exit 1
          fi
          # Strip 'v' prefix if present
          TAG_STRIPPED=${TAG#v}
          echo "tag=$TAG_STRIPPED" >> $GITHUB_OUTPUT
          echo "Found tag: $TAG (stripped: $TAG_STRIPPED)"

      - name: Download .deb files from GitHub Release
        if: ${{ inputs.skip_build }}
        env:
          VERSION: ${{steps.tag.outputs.tag}}
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p dist
          gh release download ${VERSION} --pattern "testkube_${VERSION}_linux_*.deb" --dir dist

      - name: Publish package
        env:
          USERNAME: "aptly"
          PASSWORD: ${{ secrets.APTLY_PASSWORD }}
          APTLY_URL: "repo.testkube.io:8080"
          VERSION: ${{steps.tag.outputs.tag}}
        run: |
          ### Clean temporary file directory first (in case of re-runs)
          curl -u ${USERNAME}:${PASSWORD} -X DELETE http://${APTLY_URL}/api/files/testkube || true

          ### Remove existing packages from the repository (ignore errors if they don't exist)
          curl -u ${USERNAME}:${PASSWORD} -X DELETE "http://${APTLY_URL}/api/repos/testkube/packages?q=testkube+%28%3D+${VERSION}%29" || true

          ### Upload files for all architectures
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X POST -F file=@dist/testkube_${VERSION}_linux_amd64.deb http://${APTLY_URL}/api/files/testkube
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X POST -F file=@dist/testkube_${VERSION}_linux_arm64.deb http://${APTLY_URL}/api/files/testkube
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X POST -F file=@dist/testkube_${VERSION}_linux_386.deb http://${APTLY_URL}/api/files/testkube

          ### Add file to repo
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X POST http://${APTLY_URL}/api/repos/testkube/file/testkube

          ### Create snapshot with timestamp to avoid conflicts on re-runs
          SNAPSHOT_NAME="testkube-${VERSION}-$(date +%s)"
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X POST -H 'Content-Type: application/json' --data '{"Name":"'${SNAPSHOT_NAME}'"}' http://${APTLY_URL}/api/repos/testkube/snapshots

          ### Publish repo with new snapshot (ForceOverwrite handles conflicts in published pool)
          curl --fail-with-body -u ${USERNAME}:${PASSWORD} -X PUT -H 'Content-Type: application/json' --data '{"Snapshots": [{"Component": "main", "Name": "'${SNAPSHOT_NAME}'"}], "ForceOverwrite": true}' http://repo.testkube.io:8080/api/publish/:linux/linux
